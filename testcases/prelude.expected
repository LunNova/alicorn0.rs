{ " FIXME: type of universe", " we need to wrap this, and wrap takes a type in star-10", " so we have to settle for star-9", { "let", "omega", "=", 9 }, " FIXME: apparently variables aren't allowed here", "let universe = type_(omega, 1)", { "let", "universe", "=", { "type_", 9, 1 } }, { "let", "type-omega", "=", { "type_", 9, 0 } }, { "let", "type-omega+1", "=", { "type_", 10, 0 } }, " nor expressions", "let implicit-wrap = lambda_curry ((T : type_(omega + 1, 0)))\nlambda (x : T)\n\twrap T x", { "let", "implicit-wrap", "=", "lambda_curry", { { "T", ":", "type-omega+1" } }, { "lambda", { "x", ":", "T" }, { "wrap", "T", "x" } } }, { "let", "implicit-unwrap", "=", "lambda_implicit", { "T", ":", "type-omega+1" }, { "lambda", { "x", ":", { "wrapped", "T" } }, { "unwrap", "T", "x" } } }, "let implicit-unstrict-wrap = lambda_curry ((T : type-omega+1))\n\tlambda (x : T)\n\t\tunstrict-wrap T x\n\nlet implicit-unstrict-unwrap = lambda_implicit (T : type-omega+1)\n\tlambda (x : unstrict-wrapped(T))\n\t\tunstrict-unwrap T x", { "let", "tuple-of", "=", "lambda_implicit", { "T", ":", "type-omega+1" }, { "lambda_single", { "xs", ":", "T" }, "xs" } }, { "let", "explicit-unwrap", "=", "unwrap" }, { "let", "wrap", "=", "implicit-wrap" }, { "let", "unwrap", "=", "implicit-unwrap" }, "let unstrict-wrap = implicit-unstrict-wrap\nlet unstrict-unwrap = implicit-unstrict-unwrap", { "let", "host-bool-wrap", "=", "intrinsic", { elements = { "return terms.strict_value.host_bool_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-string-wrap", "=", "intrinsic", { elements = { "return terms.strict_value.host_string_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-syntax-wrap", "=", "intrinsic", { elements = { "return terms.host_syntax_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-environment-wrap", "=", "intrinsic", { elements = { "return terms.host_environment_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-goal-wrap", "=", "intrinsic", { elements = { "return terms.host_goal_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-inferrable-term-wrap", "=", "intrinsic", { elements = { "return terms.host_inferrable_term_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-checkable-term-wrap", "=", "intrinsic", { elements = { "return terms.host_checkable_term_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-lua-error-wrap", "=", "intrinsic", { elements = { "return terms.host_lua_error_type" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-bool", "=", { "unwrap", "host-bool-wrap" } }, { "let", "host-string", "=", { "unwrap", "host-string-wrap" } }, { "let", "host-syntax", "=", { "unwrap", "host-syntax-wrap" } }, { "let", "host-environment", "=", { "unwrap", "host-environment-wrap" } }, { "let", "host-goal", "=", { "unwrap", "host-goal-wrap" } }, { "let", "host-inferrable-term", "=", { "unwrap", "host-inferrable-term-wrap" } }, { "let", "host-checkable-term", "=", { "unwrap", "host-checkable-term-wrap" } }, { "let", "host-lua-error", "=", { "unwrap", "host-lua-error-wrap" } }, { "let", "srel", "=", "lambda_implicit", { "U", ":", "type-omega+1" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#srel\", function(target)\n\treturn U.notail(terms.typed_term.srel_type(target))\nend, \"target\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "target", ":", "U" } }, "->", { "rel", ":", "U" } } } } } }, { "let", "variance", "=", "lambda_implicit", { "U", ":", "type-omega+1" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#variance\", function(target)\n\treturn U.notail(terms.typed_term.variance_type(target))\nend, \"target\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "target", ":", "U" } }, "->", { "res", ":", "U" } } } } } }, { "let", "subtyping", "=", "intrinsic", { elements = { "return evaluator.UniverseOmegaRelation" }, kind = "string" }, ":", { "srel", "type-omega" } }, { "let", "tuple-desc-type", "=", "lambda_implicit", { "U", ":", "universe" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#tuple-desc-type\", function(a_universe)\n\treturn U.notail(terms.typed_term.tuple_desc_type(a_universe))\nend, \"a_universe\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "a-universe", ":", "U" } }, "->", { "desc", ":", "U" } } } } } }, { "let", "tuple-desc-relation", "=", "intrinsic", { elements = { "return evaluator.TupleDescRelation" }, kind = "string" }, ":", { "srel", { "tuple-desc-type", "type-omega" } } }, { "let", "_|_", "=", "lambda_implicit", { "U", ":", "type-omega+1" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#union\", function(left, right)\n\treturn U.notail(terms.typed_term.union_type(left, right))\nend, \"left\", \"right\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "left", ":", "U" }, { "right", ":", "U" } }, "->", { "union", ":", "U" } } } } } }, { "let", "_&_", "=", "lambda_implicit", { "U", ":", "type-omega+1" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#intersection\", function(left, right)\n\treturn U.notail(terms.typed_term.intersection_type(left, right))\nend, \"left\", \"right\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "left", ":", "U" }, { "right", ":", "U" } }, "->", { "intersection", ":", "U" } } } } } }, { "let", "covariant", "=", "lambda_curry", { { "U", ":", "universe" }, { "a", ":", "U" } }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#covariant\", function(rel)\n\tlocal positive = terms.typed_term.literal(terms.strict_value.host_value(true))\n\treturn U.notail(terms.typed_term.variance_cons(positive, rel))\nend, \"rel\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "rel", ":", { "srel", "a" } } }, "->", { "covariant-rel", ":", { "variance", "a" } } } } } } }, { "let", "contravariant", "=", "lambda_curry", { { "U", ":", "universe" }, { "a", ":", "U" } }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#contravariant\", function(rel)\n\tlocal positive = terms.typed_term.literal(terms.strict_value.host_value(false))\n\treturn U.notail(terms.typed_term.variance_cons(positive, rel))\nend, \"rel\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "rel", ":", { "srel", "a" } } }, "->", { "contravariant-rel", ":", { "variance", "a" } } } } } } }, { "let", "tuple-type", "=", "lambda_implicit", { "U", ":", "universe" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#tuple-type\", function(desc)\n\treturn U.notail(terms.typed_term.tuple_type(desc))\nend, \"desc\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "desc", ":", { "tuple-desc-type", "U" } } }, "->", { "T", ":", "U" } } } } } }, { "let", "host-tuple-type", "=", { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#host-tuple-type\", function(desc)\n\treturn U.notail(terms.typed_term.host_tuple_type(desc))\nend, \"desc\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "desc", ":", { "tuple-desc-type", "host-type" } } }, "->", { "T", ":", "host-type" } } } } } }, { "let", "host-family-sig-variances", "=", "lambda", { "signature", ":", { "type_", 1, 0 } }, { "let", "inner", "=", "intrinsic", { elements = { "return base_env.convert_sig" }, kind = "string" }, ":", { "host-func-type", { { "signature", ":", { "wrapped", { "type_", 1, 0 } } } }, "->", { { "srel_type", ":", { "wrapped", { "type_", 1, 0 } } } } } }, { "let", { "srels-t" }, "=", { "inner", { "wrap", "signature" } } }, { "unwrap", "srels-t" } }, { "let", "host-string-concat", "=", "intrinsic", { elements = { "return function(a, b) return U.notail(a .. b) end" }, kind = "string" }, ":", { "host-func-type", { { "a", ":", "host-string" }, { "b", ":", "host-string" } }, "->", { { "c", ":", "host-string" } } } }, " TODO: now that we have effectful programs, work to switch this into using an effect to serialize the operations", " lmao bootstrapping problem", { "let", "host-unique-id-wrap", "=", "intrinsic", { elements = { "local id = { name = \"unique_id\" }\nevaluator.register_host_srel(id, evaluator.IndepTupleRelation({}))\nreturn U.notail(terms.strict_value.host_user_defined_type(id, terms_gen.declare_array(terms.strict_value)()))" }, kind = "string" }, ":", { "wrapped", "host-type" } }, { "let", "host-unique-id", "=", { "unwrap", "host-unique-id-wrap" } }, { "let", "new-host-unique-id", "=", "lambda", { "name", ":", "host-string" }, { "let", "source0", "=", { elements = { "return { name = \"" }, kind = "string" } }, { "let", { "source1" }, "=", { "host-string-concat", "source0", "name" } }, { "let", { "source2" }, "=", { "host-string-concat", "source1", { elements = { "\" }" }, kind = "string" } } }, { "intrinsic", "source2", ":", "host-unique-id" } }, { "let", "new-host-type-family", "=", "lambda", { { "unique-id", ":", "host-unique-id" }, { "signature", ":", { "type_", 1, 0 } }, { "variance", ":", { "host-family-sig-variances", "signature" } } }, { "let", "inner", "=", "intrinsic", { elements = { "return base_env.new_host_type_family" }, kind = "string" }, ":", { "host-func-type", { { "unique-id", ":", "host-unique-id" }, { "signature_", ":", { "wrapped", { "type_", 1, 0 } } }, { "variance_", ":", { "wrapped", { "host-family-sig-variances", { "unwrap", "signature_" } } } } }, "->", { { "family", ":", { "wrapped", { "unwrap", "signature_" } } } } } }, { "let", { "family" }, "=", { "inner", "unique-id", { "wrap", "signature" }, { "wrap", "variance" } } }, { "unwrap", "family" } }, { "let", "new-host-type", "=", "lambda", { "unique-id", ":", "host-unique-id" }, { "let", "Tfam", "=", "new-host-type-family", "unique-id", { "forall", { }, "->", { "T", ":", "host-type" } }, { "tuple-of" } }, { "Tfam" } }, { "let", "host-array-type", "=", "new-host-type-family", { "new-host-unique-id", { elements = { "array" }, kind = "string" } }, { "forall", { { "T", ":", "host-type" } }, "->", { "T", ":", "host-type" } }, { "tuple-of", { "covariant", "subtyping" } } }, { "let", "host-array-new", "=", "lambda", { "T", ":", "host-type" }, { "let", "inner", "=", "intrinsic", { elements = { "local function array_new()\n\treturn {}\nend\nreturn array_new" }, kind = "string" }, ":", { "host-func-type", { }, "->", { { "arr", ":", { "host-array-type", "T" } } } } }, { "let", { "arr" }, "=", { "inner" } }, "arr" }, { "let", "host-array-set", "=", "lambda_implicit", { "T", ":", "host-type" }, { "lambda", { { "arr", ":", { "host-array-type", "T" } }, { "index", ":", "host-number" }, { "elem", ":", "T" } }, { "let", "inner", "=", "intrinsic", { elements = { "local function array_set(array, index, elem)\n\t-- we have to clone because can't guarantee input array isn't reused\n\t-- Yet. growth mindset.\n\tcloned = {}\n\tfor i, v in ipairs(array) do\n\t\tcloned[i] = v\n\tend\n\tcloned[index] = elem\n\treturn cloned\nend\nreturn array_set" }, kind = "string" }, ":", { "host-func-type", { { "arr", ":", { "host-array-type", "T" } }, { "index", ":", "host-number" }, { "elem", ":", "T" } }, "->", { { "arr", ":", { "host-array-type", "T" } } } } }, { "let", { "arr" }, "=", { "inner", "arr", "index", "elem" } }, "arr" } }, { "let", "host-array-get", "=", "lambda_implicit", { "T", ":", "host-type" }, { "lambda", { { "arr", ":", { "host-array-type", "T" } }, { "index", ":", "host-number" } }, { "let", "inner", "=", "intrinsic", { elements = { "local function array_get(array, index)\n\treturn U.notail(array[index])\nend\nreturn array_get" }, kind = "string" }, ":", { "host-func-type", { { "arr", ":", { "host-array-type", "T" } }, { "index", ":", "host-number" } }, "->", { { "elem", ":", "T" } } } }, { "let", { "elem" }, "=", { "inner", "arr", "index" } }, "elem" } }, { "let", "terms-gen-array", "=", { "new-host-type", { "new-host-unique-id", { elements = { "terms-gen-array" }, kind = "string" } } } }, { "let", "void", "=", { "unwrap", { "intrinsic", { elements = { "local desc = terms.empty\nlocal basetype = terms.strict_value.enum_type(desc:unwrap_strict())\nreturn basetype" }, kind = "string" }, ":", { "wrapped", "type" } } } }, { "let", "host-unit", "=", { "new-host-type", { "new-host-unique-id", { elements = { "host-unit" }, kind = "string" } } } }, { "let", "host-nil", "=", "intrinsic", { elements = { "return nil" }, kind = "string" }, ":", "host-unit" }, { "let", "only-accept-host-tuples-inner-host", "=", { "intrinsic", { elements = { "local function check_host_tuple(subject, consequent, alternate)\n\tif subject:is_host_tuple_type() then\n\t\treturn consequent\n\telse\n\t\treturn alternate\n\tend\nend\nreturn check_host_tuple" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", { "wrapped", "host-type" } }, { "alternate", ":", { "wrapped", "host-type" } } }, "->", { { "result", ":", { "wrapped", "host-type" } } } } } }, { "let", "only-accept-host-tuples-inner", "=", { "lambda", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", "host-type" }, { "alternate", ":", "host-type" } }, { "let", { "res" }, "=", { "only-accept-host-tuples-inner-host", "subject", { "wrap", "consequent" }, { "wrap", "alternate" } } }, { "unwrap", "res" } } }, { "let", "only-accept-host-tuples", "=", { "lambda", { "subject", ":", { "wrapped", "type" } }, { "only-accept-host-tuples-inner", "subject", "host-unit", { "wrapped", "void" } } } }, { "let", "only-accept-prog-host-tuples-inner-host", "=", { "intrinsic", { elements = { "local function check_prog_host_tuple(subject, consequent, alternate)\n\tif not subject:is_program_type() then\n\t\treturn alternate\n\tend\n\tlocal effects, base = subject:unwrap_program_type()\n\tif base:is_host_tuple_type() then\n\t\treturn consequent\n\telse\n\t\treturn alternate\n\tend\nend\nreturn check_prog_host_tuple" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", { "wrapped", "host-type" } }, { "alternate", ":", { "wrapped", "host-type" } } }, "->", { { "result", ":", { "wrapped", "host-type" } } } } } }, { "let", "only-accept-prog-host-tuples-inner", "=", { "lambda", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", "host-type" }, { "alternate", ":", "host-type" } }, { "let", { "res" }, "=", { "only-accept-prog-host-tuples-inner-host", "subject", { "wrap", "consequent" }, { "wrap", "alternate" } } }, { "unwrap", "res" } } }, { "let", "only-accept-prog-host-tuples", "=", { "lambda", { "subject", ":", { "wrapped", "type" } }, { "only-accept-host-tuples-inner", "subject", "host-unit", { "wrapped", "void" } } } }, { "let", "host-tuple-type-to-tuple-type-inner", "=", { "intrinsic", { elements = { "local function host_tuple_to_tuple(host_tuple_type)\n\tlocal desc = host_tuple_type:unwrap_host_tuple_type()\n\t-- this conversion happens to work since the eliminator for host tuples and tuples is the same term\n\tlocal new_base_type = terms.strict_value.tuple_type(desc)\n\treturn new_base_type\nend\nreturn host_tuple_to_tuple" }, kind = "string" }, ":", { "host-func-type", { { "t", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-tuples", "t" } } }, "->", { { "res", ":", { "wrapped", "type" } } } } } }, { "let", "host-tuple-type-to-tuple-type", "=", { "lambda", { { "t", ":", "type" }, { "valid", ":", { "only-accept-host-tuples", { "wrap", "t" } } } }, { "let", { "res" }, "=", { "host-tuple-type-to-tuple-type-inner", { "wrap", "t" }, "valid" } }, { "unwrap", "res" } } }, { "let", "extract-prog-host-tuple-type-inner", "=", { "intrinsic", { elements = { "return function(prog_type)\n\tlocal effect, base = prog_type:unwrap_program_type()\n\treturn base\nend" }, kind = "string" }, ":", { "host-func-type", { { "t", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-prog-host-tuples", "t" } } }, "->", { { "res", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-tuples", "res" } } } } } }, { "let", "extract-prog-host-tuple-type", "=", { "lambda", { { "t", ":", "type" }, { "valid", ":", { "only-accept-prog-host-tuples", { "wrap", "t" } } } }, { "let", { "res", "valid" }, "=", { "extract-prog-host-tuple-type-inner", { "wrap", "t" }, "valid" } }, { "tuple-of", { "unwrap", "res" }, "valid" } } }, { "let", "rebuild-prog-type-inner", "=", { "intrinsic", { elements = { "return function(prog_type, valid, new_base)\n\tlocal effect, base = prog_type:unwrap_program_type()\n\treturn U.notail(terms.strict_value.program_type(effect, new_base))\nend" }, kind = "string" }, ":", { "host-func-type", { { "t", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-prog-host-tuples", "t" } }, { "b", ":", { "wrapped", "type" } } }, "->", { { "res", ":", { "wrapped", "type" } } } } } }, { "let", "rebuild-prog-type", "=", { "lambda", { { "t", ":", "type" }, { "valid", ":", { "only-accept-prog-host-tuples", { "wrap", "t" } } }, { "b", ":", "type" } }, { "let", { "res" }, "=", { "rebuild-prog-type-inner", { "wrap", "t" }, "valid", { "wrap", "b" } } }, { "unwrap", "res" } } }, "let host-tuple-to-tuple-inner =\n\tintrinsic\n\t\t\"\"\"\"\n\t\t\treturn function(_type, _valid, val)\n\t\t\t\tlocal elems = val:unwrap_host_tuple_value()\n\t\t\t\tlocal vals = terms_gen.declare_array(terms.strict_value)()\n\t\t\t\tfor _, v in ipairs(elems) do\n\t\t\t\t\tvals:append(terms.strict_value.host_value(v))\n\t\t\t\tend\n\t\t\t\treturn U.notail(terms.strict_value.tuple_value(vals))\n\t\t\tend\n\t\t:\n\t\thost-func-type (\n\t\t\t\tt     : wrapped(type),\n\t\t\t\tvalid : only-accept-host-tuples(t),\n\t\t\t\tval   : wrapped(unwrap(t)))\n\t\t\t->\n\t\t\t((res : wrapped(host-tuple-type-to-tuple-type(unwrap(t), valid))))\n\nlet host-tuple-to-tuple =\n\tlambda (t : wrapped(type), valid : only-accept-host-tuples(t), val : unwrap(t))\n\t\tlet (res) = host-tuple-to-tuple-inner(t, valid, wrap(val))\n\t\tunwrap(res)", { "let", "host-tuple-to-tuple", "=", { "lambda_implicit", { "desc", ":", { "tuple-desc-type", "host-type" } }, { "lambda", { "xs", ":", { "host-tuple-type", "desc" } }, { "let", "inner", "=", "intrinsic", { elements = { "return function(val)\n\tlocal elems = val:unwrap_host_tuple_value()\n\tlocal vals = terms_gen.declare_array(terms.strict_value)()\n\tfor _, v in ipairs(elems) do\n\t\tvals:append(terms.strict_value.host_value(v))\n\tend\n\treturn U.notail(terms.strict_value.tuple_value(vals))\nend" }, kind = "string" }, ":", { "host-func-type", { { "val", ":", { "wrapped", { "host-tuple-type", "desc" } } } }, "->", { { "res", ":", { "wrapped", { "tuple-type", "desc" } } } } } }, { "let", { "res" }, "=", { "inner", { "wrap", "xs" } } }, { "the", { "tuple-type", "desc" }, { "unwrap", "res" } } } } }, { "let", "tuple-to-host-tuple", "=", { "lambda_implicit", { "desc", ":", { "tuple-desc-type", "host-type" } }, { "lambda", { "xs", ":", { "tuple-type", "desc" } }, { "let", "inner", "=", { "intrinsic", { elements = { "return function(val) return base_env.tuple_to_host_tuple_inner(nil, nil, val) end" }, kind = "string" }, ":", { "host-func-type", { { "val", ":", { "wrapped", { "tuple-type", "desc" } } } }, "->", { { "res", ":", { "wrapped", { "host-tuple-type", "desc" } } } } } } }, { "let", { "res" }, "=", { "inner", { "wrap", "xs" } } }, { "unwrap", "res" } } } }, { "let", "only-accept-host-funcs-inner-host", "=", { "intrinsic", { elements = { "---@param subject strict_value\n---@param consequent strict_value\n---@param alternate strict_value\n---@return strict_value\nlocal function check_host_func(subject, consequent, alternate)\n\tif subject:is_host_function_type() then\n\t\tlocal param, result, info = subject:unwrap_host_function_type()\n\t\tif not info:is_result_info() then\n\t\t\terror \"stuck result info? broken function type?\"\n\t\tend\n\t\tlocal info_inner = info:unwrap_result_info()\n\t\tlocal purity = info_inner:unwrap_result_info()\n\t\tif purity:is_pure() then\n\t\t\treturn consequent\n\t\telse\n\t\t\treturn alternate\n\t\tend\n\telse\n\t\treturn alternate\n\tend\nend\nreturn check_host_func" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", { "wrapped", "host-type" } }, { "alternate", ":", { "wrapped", "host-type" } } }, "->", { { "result", ":", { "wrapped", "host-type" } } } } } }, { "let", "only-accept-host-funcs-inner", "=", { "lambda", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", "host-type" }, { "alternate", ":", "host-type" } }, { "let", { "res" }, "=", { "only-accept-host-funcs-inner-host", "subject", { "wrap", "consequent" }, { "wrap", "alternate" } } }, { "unwrap", "res" } } }, { "let", "only-accept-host-funcs", "=", { "lambda", { "subject", ":", { "wrapped", "type" } }, { "only-accept-host-funcs-inner", "subject", "host-unit", { "wrapped", "void" } } } }, { "let", "only-accept-host-funcprogs-inner-host", "=", { "intrinsic", { elements = { "local function check_host_func(subject, consequent, alternate)\n\tif subject:is_host_function_type() then\n\t\tlocal param, result, info = subject:unwrap_host_function_type()\n\t\tif not info:is_result_info() then\n\t\t\terror \"stuck result info? broken function type?\"\n\t\tend\n\t\tlocal info_inner = info:unwrap_result_info()\n\t\tif info_inner.purity:is_effectful() then\n\t\t\treturn consequent\n\t\telse\n\t\t\treturn alternate\n\t\tend\n\telse\n\t\treturn alternate\n\tend\nend\nreturn check_host_func" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", { "wrapped", "host-type" } }, { "alternate", ":", { "wrapped", "host-type" } } }, "->", { { "result", ":", { "wrapped", "host-type" } } } } } }, { "let", "only-accept-host-funcprogs-inner", "=", { "lambda", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", "host-type" }, { "alternate", ":", "host-type" } }, { "let", { "res" }, "=", { "only-accept-host-funcprogs-inner-host", "subject", { "wrap", "consequent" }, { "wrap", "alternate" } } }, { "unwrap", "res" } } }, { "let", "only-accept-host-funcprogs", "=", { "lambda", { "subject", ":", { "wrapped", "type" } }, { "only-accept-host-funcprogs-inner", "subject", "host-unit", { "wrapped", "void" } } } }, { "let", "only-accept-funcs-inner-host", "=", { "intrinsic", { elements = { "local function check_host_func(subject, consequent, alternate)\n\tif subject:is_pi() then\n\t\treturn consequent\n\telse\n\t\treturn alternate\n\tend\nend\nreturn check_host_func" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", { "wrapped", "host-type" } }, { "alternate", ":", { "wrapped", "host-type" } } }, "->", { { "result", ":", { "wrapped", "host-type" } } } } } }, { "let", "only-accept-funcs-inner", "=", { "lambda", { { "subject", ":", { "wrapped", "type" } }, { "consequent", ":", "host-type" }, { "alternate", ":", "host-type" } }, { "let", { "res" }, "=", { "only-accept-funcs-inner-host", "subject", { "wrap", "consequent" }, { "wrap", "alternate" } } }, { "unwrap", "res" } } }, { "let", "only-accept-funcs", "=", { "lambda", { { "subject", ":", { "wrapped", "type" } } }, { "only-accept-funcs-inner", "subject", "host-unit", { "wrapped", "void" } } } }, { "let", "get-host-func-arg", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-host-funcs", { "wrap", "subject" } } } }, { "let", "inner", "=", { "intrinsic", { elements = { "local function get_host_func_arg(subject, valid)\n\tlocal param_type, result_type, result_info = subject:unwrap_host_function_type()\n\treturn param_type, nil\nend\nreturn get_host_func_arg" }, kind = "string" }, ":", { "host-func-type", { { "subject_", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-funcs", "subject_" } } }, "->", { { "result", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-tuples", "result" } } } } } }, { "let", { "res", "resvalid" }, "=", { "inner", { "wrap", "subject" }, "valid" } }, { "tuple-of", { "unwrap", "res" }, "resvalid" } } }, { "let", "get-host-funcprog-arg", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-host-funcprogs", { "wrap", "subject" } } } }, { "let", "inner", "=", { "intrinsic", { elements = { "local function get_host_func_arg(subject, valid)\n\tlocal param_type, result_type, result_info = subject:unwrap_host_function_type()\n\treturn param_type, nil\nend\nreturn get_host_func_arg" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-funcprogs", "subject" } } }, "->", { { "result", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-tuples", "result" } } } } } }, { "let", { "res", "resvalid" }, "=", { "inner", { "wrap", "subject" }, "valid" } }, { "tuple-of", { "unwrap", "res" }, "resvalid" } } }, { "let", "just-args", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-host-funcs", { "wrap", "subject" } } } }, { "let", { "result", "valid" }, "=", { "get-host-func-arg", "subject", "valid" } }, "result" } }, { "let", "func-result-info", "=", { "new-host-type", { "new-host-unique-id", { elements = { "func-result-info" }, kind = "string" } } } }, { "let", "get-host-func-result-info-inner", "=", { "intrinsic", { elements = { "local function get_host_func_arg(subject, valid)\n\tlocal param_type, result_type, result_info = subject:unwrap_host_function_type()\n\treturn result_info\nend\nreturn get_host_func_arg" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-funcs", "subject" } } }, "->", { { "result", ":", { "wrapped", "func-result-info" } } } } } }, { "let", "get-host-func-result-info", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-host-funcs", { "wrap", "subject" } } } }, { "let", { "res" }, "=", { "get-host-func-result-info-inner", { "wrap", "subject" }, "valid" } }, { "unwrap", "res" } } }, { "let", "set-func-result-info", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-funcs", { "wrap", "subject" } } }, { "resinf", ":", "func-result-info" } }, { "let", "inner", "=", "intrinsic", { elements = { "local function get_host_func_arg(subject, valid, new_result_info)\n\tlocal param_type, param_info, result_type, result_info = subject:unwrap_pi()\n\treturn U.notail(terms.strict_value.pi(param_type, param_info, result_type, new_result_info))\nend\nreturn get_host_func_arg" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-funcs", "subject" } }, { "resinf", ":", { "wrapped", "func-result-info" } } }, "->", { { "result", ":", { "wrapped", "type" } } } } }, { "let", { "res" }, "=", { "inner", { "wrap", "subject" }, "valid", { "wrap", "resinf" } } }, { "unwrap", "res" } } }, { "let", "func-conv-res-type", "=", { "lambda", { "argtype", ":", "type" }, { "forall", { "arg", ":", "argtype" }, "->", { { "res", ":", "type" }, { "valid", ":", { "only-accept-host-tuples", { "wrap", "res" } } } } } } }, { "let", "funcprog-conv-res-type", "=", { "lambda", { "argtype", ":", "type" }, { "forall", { "arg", ":", "argtype" }, "->", { { "res", ":", "type" }, { "valid", ":", { "only-accept-prog-host-tuples", { "wrap", "res" } } } } } } }, { "let", "get-host-func-res", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-host-funcs", { "wrap", "subject" } } } }, { "let", "inner", "=", "intrinsic", { elements = { "return base_env.get_host_func_res" }, kind = "string" }, ":", { "host-func-type", { { "subject_", ":", { "wrapped", "type" } }, { "valid_", ":", { "only-accept-host-funcs", "subject_" } } }, "->", { { "results", ":", { "wrapped", { "func-conv-res-type", { "just-args", { "unwrap", "subject_" }, "valid_" } } } } } } }, { "let", { "res" }, "=", { "inner", { "wrap", "subject" }, "valid" } }, { "unwrap", "res" } } }, { "let", "get-host-funcprog-res", "=", { "lambda", { { "subject", ":", "type" }, { "valid", ":", { "only-accept-host-funcprogs", { "wrap", "subject" } } } }, { "let", "inner", "=", { "intrinsic", { elements = { "return base_env.get_host_func_res" }, kind = "string" }, ":", { "host-func-type", { { "subject", ":", { "wrapped", "type" } }, { "valid", ":", { "only-accept-host-funcprogs", "subject" } } }, "->", { { "results", ":", { "wrapped", { "funcprog-conv-res-type", { "just-args", { "unwrap", "subject" }, "valid" } } } } } } } }, { "let", { "res" }, "=", { "inner", { "wrap", "subject" }, "valid" } }, { "unwrap", "res" } } }, { "let", "func-to-host-func", "=", { "lambda_curry", { { "arg-desc", ":", { "tuple-desc-type", "host-type" } }, { "res-desc", ":", { "forall", { "x", ":", { "tuple-type", "arg-desc" } }, "->", { "r", ":", { "tuple-desc-type", "host-type" } } } } }, { "let", "ft", "=", "forall", { "args", ":", { "tuple-type", "arg-desc" } }, "->", { "res", ":", { "tuple-type", { "apply", "res-desc", "args" } } } }, { "let", "hft", "=", "host-func-type", { "args", ":", { "host-tuple-type", "arg-desc" } }, "->", { "res", ":", { "host-tuple-type", { "apply", "res-desc", { "host-tuple-to-tuple", "args" } } } } }, { "lambda", { "f", ":", "ft" }, { "let", "inner", "=", "intrinsic", { elements = { "return function(afn)\n\treturn function(...)\n\t\tlocal args = table.pack(...)\n\t\tlocal conv_args = terms_gen.declare_array(terms.flex_value)()\n\t\tfor i = 1, args.n do\n\t\t\tconv_args:append(terms.flex_value.host_value(args[i]))\n\t\tend\n\t\tlocal res = evaluator.apply_value(terms.flex_value.strict(afn), terms.flex_value.tuple_value(conv_args), terms.typechecking_context())\n\t\tif not res:is_tuple_value() then\n\t\t\terror \"alicorn function converted to native function has failed to create a real value\"\n\t\tend\n\t\tlocal elems = {}\n\t\tfor i, v in res:unwrap_tuple_value():ipairs() do\n\t\t\telems[i] = v:unwrap_host_value()\n\t\tend\n\t\treturn table.unpack(elems)\n\tend\nend" }, kind = "string" }, ":", { "host-func-type", { { "arg", ":", { "wrapped", "ft" } } }, "->", { { "res", ":", "hft" } } } }, { "let", { "res" }, "=", { "inner", { "wrap", "f" } } }, { "the", "hft", "res" } } } }, "let host-func-type-to-func-type =\n\tlambda (T : type, valid : only-accept-host-funcs(wrap(T)))\n\t\tlet (oldargs oldargs-valid) = get-host-func-arg(T, valid)\n\t\tlet newargs = host-tuple-type-to-tuple-type(oldargs, oldargs-valid)\n\t\tlet orig-results = get-host-func-res(T, valid)\n\t\tlet orig-result-info = get-host-func-result-info(T, valid)\n\n\t\tlet new-results =\n\t\t\tlambda (args : newargs)\n\t\t\t\tlet ptuple = tuple-to-host-tuple(oldargs, oldargs-valid, args)\n\t\t\t\tlet (oldres oldres-valid) = apply(orig-results, ptuple)\n\t\t\t\tlet newres = host-tuple-type-to-tuple-type(oldres, oldres-valid)\n\t\t\t\tnewres\n\n\t\tlet new-func-type = forall (x : newargs) -> (y : new-results(x))\n\t\tlet final-func-type = set-func-result-info(new-func-type, host-nil, orig-result-info)\n\t\tfinal-func-type", "let host-funcprog-type-to-funcprog-type =\n\tlambda (T : type, valid : only-accept-host-funcprogs(wrap(T)))\n\t\tlet (oldargs oldargs-valid) = get-host-funcprog-arg(T, valid)\n\t\tlet newargs = host-tuple-type-to-tuple-type(oldargs, oldargs-valid)\n\t\tlet orig-results = get-host-funcprog-res(T, valid)\n\t\tlet orig-result-info = get-host-func-result-info(T, valid)\n\n\t\tlet new-results =\n\t\t\tlambda (args : newargs)\n\t\t\t\tlet ptuple = tuple-to-host-tuple(oldargs, oldargs-valid, args)\n\t\t\t\tlet (oldres oldres-valid) = apply(orig-results, ptuple)\n\t\t\t\tlet (extractres extractres-valid) = extract-prog-host-tuple-type(oldres, oldres-valid)\n\t\t\t\tlet newres = host-tuple-type-to-tuple-type(extractres, extractres-valid)\n\t\t\t\trebuild-prog-type(oldres, oldres-valid, newres)\n\n\t\tlet new-func-type = forall (x : newargs) -> (y : new-results(x))\n\t\tlet final-func-type = set-func-result-info(new-func-type, host-nil, orig-result-info)\n\t\tfinal-func-type", "let func-to-host-func-inner =\n\tintrinsic\n\t\t\"\"\"\"\n\t\t\treturn function(_type, _valid, afn)\n\t\t\t\treturn function(...)\n\t\t\t\t\tlocal args = table.pack(...)\n\t\t\t\t\tlocal conv_args = terms_gen.declare_array(terms.strict_value)()\n\t\t\t\t\tfor i = 1, args.n do\n\t\t\t\t\t\tconv_args:append(terms.strict_value.host_value(args[i]))\n\t\t\t\t\tend\n\t\t\t\t\tlocal res = evaluator.apply_value(afn, terms.strict_value.tuple_value(conv_args), terms.typechecking_context())\n\t\t\t\t\tif not res:is_tuple_value() then\n\t\t\t\t\t\terror \"alicorn function converted to native function has failed to create a real value\"\n\t\t\t\t\tend\n\t\t\t\t\tlocal elems = {}\n\t\t\t\t\tfor i, v in res:unwrap_tuple_value():ipairs() do\n\t\t\t\t\t\telems[i] = v:unwrap_host_value()\n\t\t\t\t\tend\n\t\t\t\t\treturn table.unpack(elems)\n\t\t\t\tend\n\t\t\tend\n\t\t:\n\t\thost-func-type (T : wrapped(host-type), valid : only-accept-host-funcs(T), fn : wrapped(host-func-type-to-func-type(unwrap(T), valid))) -> ((res-fn : unwrap(T)))", "let func-to-host-func =\n\tlambda (T : host-type, valid : only-accept-host-funcs(wrap(T)), fn : host-func-type-to-func-type(T, valid))\n\t\tlet (res) = func-to-host-func-inner(wrap(T), valid, wrap(fn))\n\t\tres #TODO figure out why `unwrap(res) here doesn't make a nice type error but fails", " TODO rewrite to handle new flex values", "let funcprog-to-host-funcprog-inner =\n\tintrinsic\n\t\t\"\"\"\"\n\t\t\treturn function(_type, _valid, afn)\n\t\t\t\treturn function(...)\n\t\t\t\t\tlocal args = {...}\n\t\t\t\t\tlocal nargs = select(\"#\", ...)\n\t\t\t\t\tlocal conv_args = terms_gen.declare_array(terms.flex_value)()\n\t\t\t\t\tfor i = 1, nargs do\n\t\t\t\t\t\tconv_args:append(terms.flex_value.host_value(args[i]))\n\t\t\t\t\tend\n\t\t\t\t\tlocal res = evaluator.execute_program(evaluator.apply_value(afn, terms.flex_value.tuple_value(conv_args), terms.typechecking_context()))\n\t\t\t\t\tif not res:is_tuple_value() then\n\t\t\t\t\t\tprint(res)\n\t\t\t\t\t\terror  \"alicorn function converted to native function has failed to create a real value\"\n\t\t\t\t\tend\n\t\t\t\t\tlocal elems = {}\n\t\t\t\t\tfor i, v in res:unwrap_tuple_value():ipairs() do\n\t\t\t\t\t\telems[i] = v:unwrap_host_value()\n\t\t\t\t\tend\n\t\t\t\t\treturn table.unpack(elems)\n\t\t\t\tend\n\t\t\tend\n\t\t:\n\t\thost-func-type (T : wrapped(host-type), valid : only-accept-host-funcprogs(T), fn : wrapped(host-funcprog-type-to-funcprog-type(unwrap(T), valid))) -> ((res-fn : unwrap(T)))", "let funcprog-to-host-funcprog =\n\tlambda (T : host-type, valid : only-accept-host-funcprogs(wrap(T)), fn : host-funcprog-type-to-funcprog-type(T, valid))\n\t\tlet (res) = funcprog-to-host-funcprog-inner(wrap(T), valid, wrap(fn))\n\t\tres #TODO figure out why `unwrap(res) here doesn't make a nice type error but fails", { "let", "host-if", "=", "lambda_implicit", { "T", ":", "type-omega" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#host-if\", function(subject, consequent, alternate)\n\treturn U.notail(terms.typed_term.host_if(subject, consequent, alternate))\nend, \"subject\", \"consequent\", \"alternate\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "subject", ":", "host-bool" }, { "consequent", ":", "T" }, { "alternate", ":", "T" } }, "->", { "res", ":", "T" } } } } } }, { "let", "tuple-desc-empty", "=", "lambda", { "U", ":", "universe" }, { "let", "empty", "=", "intrinsic", { elements = { "return terms.empty:unwrap_strict()" }, kind = "string" }, ":", { "wrapped", { "tuple-desc-type", "U" } } }, { "unwrap", "empty" } }, { "let", "tuple-desc-elem-explicit", "=", "lambda", { "U", ":", "universe" }, { "let", "U-tuple-desc-type", "=", { "tuple-desc-type", "U" } }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#tuple-desc-elem-explicit\", function(desc, elem)\n\treturn U.notail(terms.typed_cons(desc, elem))\nend, \"desc\", \"elem\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "desc", ":", "U-tuple-desc-type" }, { "elem", ":", { "forall", { "rest", ":", { "tuple-type", "desc" } }, "->", { "next", ":", "U" } } } }, "->", { "res", ":", "U-tuple-desc-type" } } } } } }, { "let", "tuple-desc-elem-implicit", "=", "lambda_implicit", { "U", ":", "universe" }, { "tuple-desc-elem-explicit", "U" } }, " FIXME: we're comparing metavariables against placeholders AGAIN AAAA", " let tuple-desc-elem-implicit2 = lambda_curry (U : universe, desc : tuple-desc-type(U))", " \tlambda (elem : (forall (rest : tuple-type(desc)) -> (next : U)))", " \t\tlet inner = intrinsic \"return terms.cons\" :", " \t\t\thost-func-type (", " \t\t\t\tdesc_ : wrapped(tuple-desc-type(U)), # aaaa shadowing", " \t\t\t\telem  : (wrapped (forall (rest : tuple-type(desc)) -> (next : U))))", " \t\t\t\t->", " \t\t\t\t((T : wrapped(tuple-desc-type(U))))", " \t\tlet (T) =", " \t\t\tinner", " \t\t\t\twrap(desc)", " \t\t\t\twrap(elem)", " \t\tunwrap(T)", { "let", "tuple-of-explicit", "=", "lambda", { { "U", ":", "universe" }, { "desc", ":", { "tuple-desc-type", "U" } } }, { "lambda_single", { "t", ":", { "tuple-type", "desc" } }, "t" } }, { "let", "host-tuple-of", "=", "lambda", { "desc", ":", { "tuple-desc-type", "host-type" } }, { "intrinsic", { elements = { "return function(...) return ... end" }, kind = "string" }, ":", { "host-func-type", { "t", ":", { "host-tuple-type", "desc" } }, "->", { "t", ":", { "host-tuple-type", "desc" } } } } }, { "let", "tuple-desc-singleton", "=", "lambda", { { "U", ":", "universe" }, { "T", ":", "U" } }, { { "tuple-desc-elem-explicit", "U" }, { "tuple-desc-empty", "U" }, { "lambda", { }, "T" } } }, " FIXME: ditto a few lines above", " let tuple-of-imp = lambda_implicit (U : universe)", " \tlambda (desc : tuple-desc-type(U))", " \t\t# ATTN: single parens here means bare lambda syntax", " \t\tlambda_single (t : tuple-type(desc))", " \t\t\tt", " let host-tuple-of-imp = lambda_implicit (U : universe)", " \tlambda (desc : tuple-desc-type(U))", " \t\tintrinsic \"return function(...) return ... end\" :", " \t\t\thost-func-type (t : host-tuple-type(desc)) -> (t : host-tuple-type(desc))", { "let", "tuple-desc-singleton", "=", "lambda", { { "U", ":", "universe" }, { "T", ":", "U" } }, { { "tuple-desc-elem-explicit", "U" }, { "tuple-desc-empty", "U" }, { "lambda", { }, "T" } } }, "let tuple-desc-concat = lambda (U : universe, head : tuple-desc-type(U), tail : tuple-desc-type(U))\n\t# woah huge intrinsic\n\tlet inner = intrinsic\n\t\t\"\"\"\"\n\t\t\treturn base_env.tuple_desc_concat\n\t\t:\n\t\thost-func-type (head : wrapped(tuple-desc-type(U)), tail : wrapped(tuple-desc-type(U))) -> ((cat : wrapped(tuple-desc-type(U))))\n\tlet (cat) = inner(wrap(head), wrap(tail))\n\tunwrap(cat)", { "let", "tuple-desc-concat-indep", "=", "lambda_implicit", { "U", ":", "universe" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#tuple-desc-concat\", function(prefix, suffix)\n\treturn U.notail(terms.typed_term.tuple_desc_concat_indep(prefix, suffix))\nend, \"prefix\", \"suffix\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "pfx", ":", { "tuple-desc-type", "U" } }, { "sfx", ":", { "tuple-desc-type", "U" } } }, "->", { "res", ":", { "tuple-desc-type", "U" } } } } } } }, { "let", "tuple-concat", "=", "lambda", { { "U", ":", "universe" }, { "head", ":", { "tuple-desc-type", "U" } }, { "tail", ":", { "tuple-desc-type", "U" } }, { "hd", ":", { "tuple-type", "head" } }, { "tl", ":", { "tuple-type", "tail" } } }, { "let", "inner", "=", "intrinsic", { elements = { "local value_array = terms_gen.declare_array(terms.strict_value)\nlocal function tuple_concat(head, tail)\n\tlocal head_elements = head:unwrap_tuple_value()\n\tlocal tail_elements = tail:unwrap_tuple_value()\n\tlocal new_elements = value_array()\n\tfor _, e in head_elements:ipairs() do\n\t\tnew_elements:append(e)\n\tend\n\tfor _, e in tail_elements:ipairs() do\n\t\tnew_elements:append(e)\n\tend\n\treturn U.notail(terms.strict_value.tuple_value(new_elements))\nend\nreturn tuple_concat" }, kind = "string" }, ":", { "host-func-type", { { "hd", ":", { "wrapped", { "tuple-type", "head" } } }, { "tl", ":", { "wrapped", { "tuple-type", "tail" } } } }, "->", { { "cat", ":", { "wrapped", { "tuple-type", { "tuple-desc-concat-indep", "head", "tail" } } } } } } }, { "let", { "cat" }, "=", { "inner", { "wrap", "hd" }, { "wrap", "tl" } } }, { "unwrap", "cat" } }, { "let", "host-tuple-concat", "=", "lambda", { { "head", ":", { "tuple-desc-type", "host-type" } }, { "tail", ":", { "tuple-desc-type", "host-type" } }, { "hd", ":", { "host-tuple-type", "head" } }, { "tl", ":", { "host-tuple-type", "tail" } } }, { "let", "inner", "=", "intrinsic", { elements = { "local value_array = terms_gen.declare_array(terms_gen.any_lua_type)\nlocal function host_tuple_concat(head, tail)\n\tlocal head_elements = head:unwrap_host_tuple_value()\n\tlocal tail_elements = tail:unwrap_host_tuple_value()\n\tlocal new_elements = value_array()\n\tfor _, e in head_elements:ipairs() do\n\t\tnew_elements:append(e)\n\tend\n\tfor _, e in tail_elements:ipairs() do\n\t\tnew_elements:append(e)\n\tend\n\treturn U.notail(terms.strict_value.host_tuple_value(new_elements))\nend\nreturn host_tuple_concat" }, kind = "string" }, ":", { "host-func-type", { { "hd", ":", { "wrapped", { "host-tuple-type", "head" } } }, { "tl", ":", { "wrapped", { "host-tuple-type", "tail" } } } }, "->", { { "cat", ":", { "wrapped", { "host-tuple-type", { "tuple-desc-concat-indep", "head", "tail" } } } } } } }, { "let", { "cat" }, "=", { "inner", { "wrap", "hd" }, { "wrap", "tl" } } }, { "unwrap", "cat" } }, " TODO rewrite for new flex_values", "let host-number-fold-indep = lambda_implicit (T : type-omega)\n\tlet inner =\n\t\tintrinsic\n\t\t\t\"\"\"\"\n\t\t\t\tlocal value_array = terms_gen.declare_array(terms.flex_value)\n\t\t\t\treturn function(n, f, acc)\n\t\t\t\t\tfor i = n, 1, -1 do\n\t\t\t\t\t\tacc = evaluator.apply_value(f, terms.flex_value.tuple_value(value_array(terms.flex_value.host_value(i), acc)), terms.typechecking_context())\n\t\t\t\t\tend\n\t\t\t\t\treturn acc\n\t\t\t\tend\n\t\t\t:\n\t\t\thost-func-type  (\n\t\t\t\t\tn : host-number,\n\t\t\t\t\tf : (wrapped (forall (i : host-number, acc : T) -> (resacc : T)) ),\n\t\t\t\t\tacc : wrapped(T))\n\t\t\t\t->\n\t\t\t\t((fold : wrapped(T)))\n\tlambda (n : host-number, f : (forall (i : host-number, acc : T) -> (resacc : T)), acc : T)\n\t\tlet  (fold) = inner(n, wrap(f), wrap(acc))\n\t\tunwrap(fold)", { "let", "host-number-fold-indep", "=", "lambda_implicit", { "T", ":", "type-omega" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#int-fold\", function(num, func, acc)\n\treturn U.notail(terms.typed_term.host_int_fold(num, func, acc))\nend, \"num\", \"func\", \"acc\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "n", ":", "host-number" }, { "f", ":", { "forall", { { "i", ":", "host-number" }, { "acc", ":", "T" } }, "->", { "resacc", ":", "T" } } }, { "acc", ":", "T" } }, "->", { "res", ":", "T" } } } } } }, { "let", "duplicate-tuple-desc", "=", "lambda_implicit", { "U", ":", "universe" }, { "lambda", { { "n", ":", "host-number" }, { "T", ":", "U" } }, { "host-number-fold-indep", "n", { "lambda", { { "i", ":", "host-number" }, { "acc", ":", { "tuple-desc-type", "U" } } }, { "tuple-desc-concat-indep", "acc", { "tuple-desc-singleton", "U", "T" } } }, { "tuple-desc-empty", "U" } } } }, { "let", "host-array-from-tuple", "=", "lambda_implicit", { "T", ":", "host-type" }, { "lambda", { { "size", ":", "host-number" }, { "tuple", ":", { "host-tuple-type", { "duplicate-tuple-desc", "size", "T" } } } }, { "let", "inner", "=", { "intrinsic", { elements = { "return function(tuple)\n\tlocal elements = tuple:unwrap_host_tuple_value(tuple)\n\treturn {elements:unpack()}\nend" }, kind = "string" }, ":", { "host-func-type", { { "tuple", ":", { "wrapped", { "host-tuple-type", { "duplicate-tuple-desc", "size", "T" } } } } }, "->", { { "res", ":", { "host-array-type", "T" } } } } } }, { "let", { "array" }, "=", { "inner", { "wrap", "tuple" } } }, "array" } }, { "let", "make-host-array", "=", "lambda_implicit", { "T", ":", "host-type" }, { "lambda", { "size", ":", "host-number" }, { "let", "input-desc", "=", { "duplicate-tuple-desc", "size", "T" } }, { "let", "host-input-type", "=", { "host-tuple-type", "input-desc" } }, { "let", "input-type", "=", { "tuple-type", "input-desc" } }, { "let", "inner", "=", { "intrinsic", { elements = { "return function(tuple)\n\tlocal elements = tuple:unwrap_host_tuple_value(tuple)\n\treturn {elements:unpack()}\nend" }, kind = "string" }, ":", { "host-func-type", { { "tuple", ":", { "wrapped", "host-input-type" } } }, "->", { { "res", ":", { "host-array-type", "T" } } } } } }, { "lambda_single", { "elems", ":", "input-type" }, { "let", "host-elems", "=", { "tuple-to-host-tuple", "elems" } }, { "let", { "array" }, "=", { "inner", { "wrap", "host-elems" } } }, "array" } } }, { "let", "test-array", "=", { { "make-host-array", 4 }, 0, 0, 0, 0 } }, "# syntax matcher and operative stuff", { "let", "host-literal", "=", { "new-host-type", { "new-host-unique-id", { elements = { "literal" }, kind = "string" } } } }, { "let", "host-expression-args", "=", { "new-host-type", { "new-host-unique-id", { elements = { "expression-args" }, kind = "string" } } } }, { "let", "expression-args-new", "=", "intrinsic", { elements = { "return alicorn_expressions.ExpressionArgs.new" }, kind = "string" }, ":", { "host-func-type", { { "goal", ":", "host-goal" }, { "env", ":", "host-environment" } }, "->", { { "args", ":", "host-expression-args" } } } }, { "let", "host-shadow-environment", "=", { "new-host-type", { "new-host-unique-id", { elements = { "shadow-environment" }, kind = "string" } } } }, { "let", "host-purity", "=", { "new-host-type", { "new-host-unique-id", { elements = { "purity" }, kind = "string" } } } }, { "let", "enter-block", "=", "intrinsic", { elements = { "-- wish environment.enter_block was accessible from internals\nlocal function enter_block(env)\n\treturn U.notail(env:enter_block(terms.block_purity.pure))\nend\nreturn enter_block" }, kind = "string" }, ":", { "host-func-type", { { "env", ":", "host-environment" } }, "->", { { "shadowed", ":", "host-shadow-environment" }, { "inner", ":", "host-environment" } } } }, { "let", "exit-block", "=", "intrinsic", { elements = { "-- wish environment.exit_block was accessible from internals\nlocal function exit_block(inner, term, shadowed)\n\treturn U.notail(inner:exit_block(term, shadowed))\nend\nreturn exit_block" }, kind = "string" }, ":", { "host-func-type", { { "inner", ":", "host-environment" }, { "term", ":", "host-inferrable-term" }, { "shadowed", ":", "host-shadow-environment" } }, "->", { { "env", ":", "host-environment" }, { "wrapped", ":", "host-inferrable-term" }, { "purity", ":", "host-purity" } } } }, { "let", "host-matcher", "=", "new-host-type-family", { "new-host-unique-id", { elements = { "matcher" }, kind = "string" } }, { "forall", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } } }, "->", { "T", ":", "host-type" } }, { "tuple-of", { "contravariant", "subtyping" }, { "covariant", "tuple-desc-relation" } } }, { "let", "nil-handler-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } } }, { "host-func-type", { { "ud", ":", "userdata" } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "let", "host-matcher-is-nil", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "accept-handler", ":", { "nil-handler-type", "userdata", "result" } } }, { "let", "inner", "=", "intrinsic", { elements = { "return metalanguage.isnil" }, kind = "string" }, ":", { "host-func-type", { { "accept-handler", ":", { "nil-handler-type", "userdata", "result" } } }, "->", { { "m", ":", { "host-matcher", "userdata", "result" } } } } }, { "let", { "m" }, "=", { "inner", "accept-handler" } }, "m" }, { "let", "pair-handler-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } } }, { "host-func-type", { { "ud", ":", "userdata" }, { "a", ":", "host-syntax" }, { "b", ":", "host-syntax" } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "let", "host-matcher-is-pair", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "accept-handler", ":", { "pair-handler-type", "userdata", "result" } } }, { "let", "inner", "=", "intrinsic", { elements = { "return metalanguage.ispair" }, kind = "string" }, ":", { "host-func-type", { { "accept-handler", ":", { "pair-handler-type", "userdata", "result" } } }, "->", { { "m", ":", { "host-matcher", "userdata", "result" } } } } }, { "let", { "m" }, "=", { "inner", "accept-handler" } }, "m" }, { "let", "symbol-handler-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } } }, { "host-func-type", { { "ud", ":", "userdata" }, { "symbol", ":", "host-string" } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "let", "host-matcher-is-symbol", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "accept-handler", ":", { "symbol-handler-type", "userdata", "result" } } }, { "let", "inner", "=", "intrinsic", { elements = { "return metalanguage.issymbol" }, kind = "string" }, ":", { "host-func-type", { { "accept-handler", ":", { "symbol-handler-type", "userdata", "result" } } }, "->", { { "m", ":", { "host-matcher", "userdata", "result" } } } } }, { "let", { "m" }, "=", { "inner", "accept-handler" } }, "m" }, { "let", "value-handler-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } } }, { "host-func-type", { { "ud", ":", "userdata" }, { "val", ":", "host-literal" } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "let", "host-matcher-is-value", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "accept-handler", ":", { "value-handler-type", "userdata", "result" } } }, { "let", "inner", "=", "intrinsic", { elements = { "return metalanguage.isvalue" }, kind = "string" }, ":", { "host-func-type", { { "accept-handler", ":", { "value-handler-type", "userdata", "result" } } }, "->", { { "m", ":", { "host-matcher", "userdata", "result" } } } } }, { "let", { "m" }, "=", { "inner", "accept-handler" } }, "m" }, { "let", "reducer-type", "=", "new-host-type-family", { "new-host-unique-id", { elements = { "host-reducer" }, kind = "string" } }, { "forall", { { "storage", ":", { "tuple-desc-type", "host-type" } }, { "result2", ":", { "tuple-desc-type", "host-type" } } }, "->", { "T", ":", "host-type" } }, { "tuple-of", { "contravariant", "tuple-desc-relation" }, { "covariant", "tuple-desc-relation" } } }, { "let", "reducible-handler-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "result2", ":", { "tuple-desc-type", "host-type" } }, { "result", ":", { "tuple-desc-type", "host-type" } } }, " prepend userdata to result2", { "let", "userdata-desc", "=", { "tuple-desc-singleton", "host-type", "userdata" } }, { "let", "params", "=", { "tuple-desc-concat-indep", "userdata-desc", "result2" } }, { "host-func-type", { "p", ":", { "host-tuple-type", "params" } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "let", "reducible-constructor-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "storage", ":", { "tuple-desc-type", "host-type" } }, { "result2", ":", { "tuple-desc-type", "host-type" } }, { "result", ":", { "tuple-desc-type", "host-type" } } }, { "let", "accept-handler-type", "=", { "reducible-handler-type", "userdata", "result2", "result" } }, " prepend accept-handler-type to storage", { "let", "accept-handler-desc", "=", { "tuple-desc-singleton", "host-type", "accept-handler-type" } }, { "let", "params", "=", { "tuple-desc-concat-indep", "accept-handler-desc", "storage" } }, { "host-func-type", { "p", ":", { "host-tuple-type", "params" } }, "->", { { "m", ":", { "host-matcher", "userdata", "result" } } } } }, { "let", "get-reducible-constructor", "=", "lambda", { { "userdata", ":", "host-type" }, { "storage", ":", { "tuple-desc-type", "host-type" } }, { "result2", ":", { "tuple-desc-type", "host-type" } }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "red", ":", { "reducer-type", "storage", "result2" } } }, { "let", "inner", "=", "intrinsic", { elements = { "return function(r) return r end" }, kind = "string" }, ":", { "host-func-type", { { "r", ":", { "reducer-type", "storage", "result2" } } }, "->", { { "c", ":", { "reducible-constructor-type", "userdata", "storage", "result2", "result" } } } } }, { "let", { "c" }, "=", { "inner", "red" } }, "c" }, { "let", "host-matcher-reducible", "=", { "lambda_implicit", { "userdata", ":", "host-type" }, { "lambda", { { "storage", ":", { "tuple-desc-type", "host-type" } }, { "result2", ":", { "tuple-desc-type", "host-type" } }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "red", ":", { "reducer-type", "storage", "result2" } }, { "s", ":", { "host-tuple-type", "storage" } }, { "accept-handler", ":", { "reducible-handler-type", "userdata", "result2", "result" } } }, " FIXME: this function resolution breaks alicorn, which is extremely very super bad", " let c = get-reducible-constructor(userdata, storage, result2, result, red)", { "let", "inner", "=", "intrinsic", { elements = { "return function(r) return r end" }, kind = "string" }, ":", { "host-func-type", { { "r", ":", { "reducer-type", "storage", "result2" } } }, "->", { { "c", ":", { "reducible-constructor-type", "userdata", "storage", "result2", "result" } } } } }, { "let", { "c" }, "=", { "inner", "red" } }, { "let", "accept-handler-type", "=", { "reducible-handler-type", "userdata", "result2", "result" } }, { "let", "accept-handler-desc", "=", { "tuple-desc-singleton", "host-type", "accept-handler-type" } }, " let red-param-desc = tuple-desc-concat(host-type, accept-handler-desc, storage)", " let red-result-desc = tuple-desc-singleton(host-type, host-matcher(userdata, result))", { "let", "accept-handler-tuple", "=", { { "host-tuple-of", "accept-handler-desc" }, "accept-handler" } }, { "let", "red-param", "=", { "host-tuple-concat", "accept-handler-desc", "storage", "accept-handler-tuple", "s" } }, " look ma, no intrinsics!", { "let", { "m" }, "=", { "apply", "c", "red-param" } }, "m" } } }, " FIXME: implicit here doesn't work", " FIXME: out of date", "let host-matcher-reducible-implicit = lambda_implicit (userdata       : host-type)\nlambda (\n\t\tstorage        : tuple-desc-type(host-type),\n\t\tresult2        : tuple-desc-type(host-type),\n\t\tresult         : tuple-desc-type(host-type),\n\t\tred            : reducer-type(userdata, storage, result2, result),\n\t\ts              : host-tuple-type(storage),\n\t\taccept-handler : reducible-handler-type(userdata, result2, result))\n\tlet accept-handler-type = reducible-handler-type(userdata, result2, result)\n\tlet accept-handler-desc = tuple-desc-singleton(host-type, accept-handler-type)\n\t# let red-param-desc = tuple-desc-concat(host-type, accept-handler-desc, storage)\n\t# let red-result-desc = tuple-desc-singleton(host-type, host-matcher(userdata, result))\n\n\tlet accept-handler-tuple = host-tuple-of(host-type, accept-handler-desc)(accept-handler)\n\tlet red-param = host-tuple-concat(host-type, accept-handler-desc, storage, accept-handler-tuple, s)\n\n\t# look ma, no intrinsics!\n\tlet (m) = apply(red, red-param)\n\tm", { "let", "failure-handler-type", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } } }, { "host-func-type", { { "ud", ":", "userdata" }, { "exception", ":", "host-lua-error" } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "let", "match-syntax", "=", "lambda", { { "userdata", ":", "host-type" }, { "result", ":", { "tuple-desc-type", "host-type" } }, { "matchers", ":", { "host-array-type", { "host-matcher", "userdata", "result" } } }, { "failure-handler", ":", { "failure-handler-type", "userdata", "result" } }, { "syn", ":", "host-syntax" }, { "ud", ":", "userdata" } }, { "let", "inner", "=", "intrinsic", { elements = { "local function match_syntax(matchers, failure_handler, syn, ud)\n\treturn U.notail(syn:match(matchers, failure_handler, ud))\nend\nreturn match_syntax" }, kind = "string" }, ":", { "host-func-type", { { "matchers", ":", { "host-array-type", { "host-matcher", "userdata", "result" } } }, { "failure-handler", ":", { "failure-handler-type", "userdata", "result" } }, { "syn", ":", "host-syntax" }, { "ud", ":", { "wrapped", "userdata" } } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "inner", "matchers", "failure-handler", "syn", { "wrap", "ud" } } }, " FIXME: implicit here doesn't work", { "let", "match-syntax-implicit", "=", "lambda_implicit", { "userdata", ":", "host-type" }, { "lambda", { { "result", ":", { "tuple-desc-type", "host-type" } }, { "matchers", ":", { "host-array-type", { "host-matcher", "userdata", "result" } } }, { "failure-handler", ":", { "failure-handler-type", "userdata", "result" } }, { "syn", ":", "host-syntax" }, { "ud", ":", "userdata" } }, { "let", "inner", "=", "intrinsic", { elements = { "local function match_syntax(matchers, failure_handler, syn, ud)\n\treturn U.notail(syn:match(matchers, failure_handler, ud))\nend\nreturn match_syntax" }, kind = "string" }, ":", { "host-func-type", { { "matchers", ":", { "host-array-type", { "host-matcher", "userdata", "result" } } }, { "failure-handler", ":", { "failure-handler-type", "userdata", "result" } }, { "syn", ":", "host-syntax" }, { "ud", ":", { "wrapped", "userdata" } } }, "->", { "r", ":", { "host-tuple-type", "result" } } } }, { "inner", "matchers", "failure-handler", "syn", { "wrap", "ud" } } } }, { "let", "host-term-of-inner", "=", "intrinsic", { elements = { "local function host_term_of(goal)\n\tif goal:is_infer() then\n\t\treturn terms.host_inferrable_term_type\n\telseif goal:is_check() then\n\t\treturn terms.host_checkable_term_type\n\telse\n\t\terror(\"host-term-of: unknown goal\")\n\tend\nend\nreturn host_term_of" }, kind = "string" }, ":", { "host-func-type", { { "goal", ":", "host-goal" } }, "->", { { "t", ":", { "wrapped", "host-type" } } } } }, "let host-term-of-inner = hackhack-host-term-of-inner", { "let", "host-term-of", "=", "lambda", { "goal", ":", "host-goal" }, { "let", { "t" }, "=", { "host-term-of-inner", "goal" } }, { "unwrap", "t" } }, { "let", "goalify-inferrable", "=", "intrinsic", { elements = { "local function goalify_inferrable(goal, inferrable)\n\tif goal:is_infer() then\n\t\treturn inferrable\n\telseif goal:is_check() then\n\t\treturn U.notail(terms.checkable_term.inferrable(inferrable))\n\telse\n\t\terror(\"goalify-inferrable: unknown goal\")\n\tend\nend\nreturn goalify_inferrable" }, kind = "string" }, ":", { "host-func-type", { { "goal", ":", "host-goal" }, { "inferrable", ":", "host-inferrable-term" } }, "->", { { "term", ":", { "host-term-of", "goal" } } } } }, { "let", "operative-handler-type", "=", "lambda", { "userdata", ":", "host-type" }, { "forall", { { "syn", ":", "host-syntax" }, { "env", ":", "host-environment" }, { "ud", ":", "userdata" }, { "goal", ":", "host-goal" } }, "->", { { "term", ":", { "host-term-of", "goal" } }, { "env", ":", "host-environment" } } } }, { "let", "operative-result-desc", "=", "lambda", { "goal", ":", "host-goal" }, " read as: (term : host-term-of(goal), env : host-environment)", { "tuple-desc-concat-indep", { "tuple-desc-singleton", "host-type", { "host-term-of", "goal" } }, { "tuple-desc-singleton", "host-type", "host-environment" } } }, { "let", "new-operative", "=", "lambda", { { "userdata", ":", "host-type" }, { "ud", ":", "userdata" }, { "handler", ":", { "operative-handler-type", "userdata" } } }, { "let", "inner", "=", "intrinsic", { elements = { "local function new_operative(userdata, ud, handler)\n\treturn\n\t\tU.notail(terms.strict_value.operative_type(handler, userdata)),\n\t\tU.notail(terms.strict_value.operative_value(ud))\nend\nreturn new_operative" }, kind = "string" }, ":", { "host-func-type", { { "userdata_", ":", { "wrapped", "host-type" } }, { "ud", ":", { "wrapped", "userdata" } }, { "handler", ":", { "wrapped", { "operative-handler-type", "userdata" } } } }, "->", { { "op-type", ":", { "wrapped", "host-type" } }, { "op", ":", { "wrapped", { "unwrap", "op-type" } } } } } }, { "let", { "op-type", "op" }, "=", { "inner", { "wrap", "userdata" }, { "wrap", "ud" }, { "wrap", "handler" } } }, { "let", "op-type", "=", { "unwrap", "op-type" } }, { "let", "op", "=", { "unwrap", "op" } }, " lol look how horrible tuple types are", " read as: (op-type : host-type, op : op-type)", { "let", "result-desc", "=", { { "tuple-desc-elem-explicit", { "type_", 1, 0 } }, { { "tuple-desc-elem-explicit", { "type_", 1, 0 } }, { "tuple-desc-empty", { "type_", 1, 0 } }, { "lambda", { }, "host-type" } }, { "lambda", { "op-type", ":", "host-type" }, "op-type" } } }, { { "tuple-of-explicit", { "type_", 1, 0 }, "result-desc" }, "op-type", "op" } }, { "let", "new-operative-implicit", "=", "lambda_implicit", { "userdata", ":", "host-type" }, { "lambda", { { "ud", ":", "userdata" }, { "handler", ":", { "operative-handler-type", "userdata" } } }, { "let", "inner", "=", "intrinsic", { elements = { "local function new_operative(userdata, ud, handler)\n\treturn\n\t\tU.notail(terms.strict_value.operative_type(handler, userdata)),\n\t\tU.notail(terms.strict_value.operative_value(ud))\nend\nreturn new_operative" }, kind = "string" }, ":", { "host-func-type", { { "userdata_", ":", { "wrapped", "host-type" } }, { "ud", ":", { "wrapped", "userdata" } }, { "handler", ":", { "wrapped", { "operative-handler-type", "userdata" } } } }, "->", { { "op-type", ":", { "wrapped", "host-type" } }, { "op", ":", { "wrapped", { "unwrap", "op-type" } } } } } }, { "let", { "op-type", "op" }, "=", { "inner", { "wrap", "userdata" }, { "wrap", "ud" }, { "wrap", "handler" } } }, { "let", "op-type", "=", { "unwrap", "op-type" } }, { "let", "op", "=", { "unwrap", "op" } }, " lol look how horrible tuple types are", " read as: (op-type : host-type, op : op-type)", { "let", "result-desc", "=", { { "tuple-desc-elem-explicit", { "type_", 1, 0 } }, { { "tuple-desc-elem-explicit", { "type_", 1, 0 } }, { "tuple-desc-empty", { "type_", 1, 0 } }, { "lambda", { }, "host-type" } }, { "lambda", { "op-type", ":", "host-type" }, "op-type" } } }, { { "tuple-of-explicit", { "type_", 1, 0 }, "result-desc" }, "op-type", "op" } } }, { "let", "core-operative-type", "=", { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#core-operative-type\", function(userdata, handler)\n\treturn U.notail(terms.typed_term.operative_type_cons(userdata, handler))\nend, \"userdata\", \"handler\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "userdata", ":", "host-type" }, { "handler", ":", { "operative-handler-type", "userdata" } } }, "->", { "res", ":", "host-type" } } } } } }, { "let", "core-operative", "=", "lambda_implicit", { "userdata", ":", "host-type" }, { "unwrap", { "intrinsic", { elements = { "return U.notail(evaluator.gen_base_operator(\"#core-operative\", function(userdata, handler)\n\t-- `handler` is intentionally discarded.\n\treturn U.notail(terms.typed_term.operative_cons(userdata))\nend, \"userdata\", \"handler\"))" }, kind = "string" }, ":", { "wrapped", { "forall", { { "ud", ":", "userdata" }, { "handler", ":", { "operative-handler-type", "userdata" } } }, "->", { "res", ":", { "core-operative-type", "userdata", "handler" } } } } } } }, "# do operative", { "let", "block-reducer-storage-desc", "=", { "tuple-desc-singleton", "host-type", "host-expression-args" } }, { "let", "block-reducer-result2-desc", "=", "operative-result-desc", " incidentally the same" }, { "let", "block-match-result-desc", "=", "lambda", { "goal", ":", "host-goal" }, " read as: (ok : host-bool, _ : host-if(ok, host-term-of(goal), host-lua-error), _ : host-if(ok, host-environment, host-unit))", " or, more logically: (ok : host-bool, ...) where:", " - ok == true:  `...` is host-term-of(goal), host-environment", " - ok == false: `...` is host-lua-error", { "tuple-desc-elem-implicit", { "tuple-desc-elem-implicit", { { "tuple-desc-elem-explicit", "host-type" }, { "tuple-desc-empty", "host-type" }, { "lambda", { }, "host-bool" } }, { "lambda", { "ok", ":", "host-bool" }, { "host-if", "ok", { "host-term-of", "goal" }, "host-lua-error" } } }, { "lambda", { { "ok", ":", "host-bool" }, { "_", ":", { "host-if", "ok", { "host-term-of", "goal" }, "host-lua-error" } } }, " hacky way to do variable-length host tuples", { "host-if", "ok", "host-environment", "host-unit" } } } }, { "let", "block-reducer", "=", "lambda", { "goal", ":", "host-goal" }, { "intrinsic", { elements = { "return alicorn_expressions.block" }, kind = "string" }, ":", { "reducer-type", "block-reducer-storage-desc", { "block-reducer-result2-desc", "goal" } } } }, { "let", "block-match-accept-handler", "=", "lambda", { "goal", ":", "host-goal" }, { "intrinsic", { elements = { "return metalanguage.accept_handler" }, kind = "string" }, ":", { "reducible-handler-type", "host-unit", { "block-reducer-result2-desc", "goal" }, { "block-match-result-desc", "goal" } } } }, { "let", "block-match-failure-handler", "=", "lambda", { "goal", ":", "host-goal" }, { "intrinsic", { elements = { "return metalanguage.failure_handler" }, kind = "string" }, ":", { "failure-handler-type", "host-unit", { "block-match-result-desc", "goal" } } } }, " alicorn doesn't have conds or branches yet so...", { "let", "error-filter", "=", "lambda", { { "Tt", ":", "host-type" }, { "Tf", ":", "host-type" }, { "ok", ":", "host-bool" }, { "val-or-err", ":", { "host-if", "ok", "Tt", "Tf" } } }, { "let", "inner", "=", "intrinsic", { elements = { "local function error_filter(ok, val_or_err)\n\tif not ok then\n\t\terror(val_or_err)\n\tend\n\treturn val_or_err\nend\nreturn error_filter" }, kind = "string" }, ":", { "host-func-type", { { "ok", ":", "host-bool" }, { "val-or-err", ":", { "host-if", "ok", "Tt", "Tf" } } }, "->", { { "val", ":", "Tt" } } } }, { "let", { "val" }, "=", { "inner", "ok", "val-or-err" } }, "val" }, " FIXME: this implicitification is incomplete!", { "let", "error-filter-implicit", "=", "lambda_curry", { { "Tt", ":", "host-type" } }, { "lambda", { { "Tf", ":", "host-type" }, { "ok", ":", "host-bool" }, { "val-or-err", ":", { "host-if", "ok", "Tt", "Tf" } } }, { "let", "inner", "=", "intrinsic", { elements = { "local function error_filter(ok, val_or_err)\n\tif not ok then\n\t\terror(val_or_err)\n\tend\n\treturn val_or_err\nend\nreturn error_filter" }, kind = "string" }, ":", { "host-func-type", { { "ok", ":", "host-bool" }, { "val-or-err", ":", { "host-if", "ok", "Tt", "Tf" } } }, "->", { { "val", ":", "Tt" } } } }, { "let", { "val" }, "=", { "inner", "ok", "val-or-err" } }, "val" } }, { "let", "goal-infer", "=", "intrinsic", { elements = { "return terms.expression_goal.infer" }, kind = "string" }, ":", "host-goal" }, { "let", "do-impl-type", "=", { "operative-handler-type", "host-unit" } }, "let do-impl = lambda (syn : host-syntax, env : host-environment, ud : host-unit, goal : host-goal)\nlet (shadowed, inner-env) = enter-block(env)\n\nswitch\n\tmatch-syntax\n\t\tmake-host-array(1)\n\t\t\thost-matcher-reducible\n\t\t\t\tblock-reducer(goal-infer)\n\t\t\t\texpression-args-new(goal-infer, inner-env)\n\t\t\t\taccept-handler\n\tOk(inner-env, term)\n\t\tlet (env, wrapped, purity) = exit-block(inner-env, term, shadowed)\n\t\tmk Ok(env, goalify-inferrable(goal, wrapped))\n\tErr e -> (mk Err e)", { "let", "do-impl", "=", "lambda", { { "syn", ":", "host-syntax" }, { "env", ":", "host-environment" }, { "ud", ":", "host-unit" }, { "goal", ":", "host-goal" } }, { "let", { "shadowed", "inner_env" }, "=", { "enter-block", "env" } }, { "let", { "args" }, "=", { "expression-args-new", "goal-infer", "inner_env" } }, { "let", "s", "=", { { "host-tuple-of", "block-reducer-storage-desc" }, "args" } }, { "let", "matcher-t", "=", { "host-matcher", "host-unit", { "block-match-result-desc", "goal-infer" } } }, { "let", "matcher", "=", { "host-matcher-reducible", "block-reducer-storage-desc", { "block-reducer-result2-desc", "goal-infer" }, { "block-match-result-desc", "goal-infer" }, { "block-reducer", "goal-infer" }, "s", { "block-match-accept-handler", "goal-infer" } } }, { "let", "matchers", "=", { "host-array-set", { "host-array-new", "matcher-t" }, 1, "matcher" } }, "let matchers = (make-host-array(1) matcher)", { "let", { "ok", "term", "inner_env" }, "=", { "match-syntax", "host-unit", { "block-match-result-desc", "goal-infer" }, "matchers", { "block-match-failure-handler", "goal-infer" }, "syn", "host-nil" } }, { "let", "term", "=", { "error-filter-implicit", "host-lua-error", "ok", "term" } }, { "let", "inner_env", "=", { "error-filter", "host-environment", "host-unit", "ok", "inner_env" } }, { "let", { "env", "wrapped", "purity" }, "=", { "exit-block", "inner_env", "term", "shadowed" } }, { "let", { "wrapped" }, "=", { "goalify-inferrable", "goal", "wrapped" } }, { { "tuple-of-explicit", "host-type", { "operative-result-desc", "goal" } }, "wrapped", "env" } }, "\tlet (do-type, do) = new-operative(host-unit, host-nil, do-impl)", { "let", "do", "=", { "core-operative", "host-nil", "do-impl" } }, "let do = into-operative(host-unit, host-nil, do-impl)", "# tuple-desc operative", { "let", "ascribed-segment-tuple-desc-reducer-thread-type", "=", { "new-host-type", { "new-host-unique-id", { elements = { "ascribed-segment-tuple-desc-reducer-thread" }, kind = "string" } } } }, { "let", "ascribed-segment-tuple-desc-reducer-thread-type-get-names", "=", "intrinsic", { elements = { "local function get_names(thread)\n\treturn thread.names\nend\nreturn get_names" }, kind = "string" }, ":", { "host-func-type", { { "thread", ":", "ascribed-segment-tuple-desc-reducer-thread-type" } }, "->", { { "names", ":", "terms-gen-array" } } } }, { "let", "ascribed-segment-tuple-desc-reducer-thread-type-get-args", "=", "intrinsic", { elements = { "local function get_args(thread)\n\treturn thread.args\nend\nreturn get_args" }, kind = "string" }, ":", { "host-func-type", { { "thread", ":", "ascribed-segment-tuple-desc-reducer-thread-type" } }, "->", { { "args", ":", "host-inferrable-term" } } } }, { "let", "ascribed-segment-tuple-desc-reducer-thread-type-get-env", "=", "intrinsic", { elements = { "local function get_env(thread)\n\treturn thread.env\nend\nreturn get_env" }, kind = "string" }, ":", { "host-func-type", { { "thread", ":", "ascribed-segment-tuple-desc-reducer-thread-type" } }, "->", { { "env", ":", "host-environment" } } } }, { "let", "ascribed-segment-tuple-desc-reducer-storage-desc", "=", { "tuple-desc-singleton", "host-type", "host-environment" } }, { "let", "ascribed-segment-tuple-desc-reducer-result2-desc", "=", { "tuple-desc-singleton", "host-type", "ascribed-segment-tuple-desc-reducer-thread-type" } }, { "let", "ascribed-segment-tuple-desc-match-result-desc", "=", " read as: (ok : host-bool, _ : host-if(ok, ascribed-segment-tuple-desc-reducer-thread-type, host-lua-error))", " or, more logically: (ok : host-bool, ...) where:", " - ok == true:  `...` is ascribed-segment-tuple-desc-reducer-thread-type", " - ok == false: `...` is host-lua-error", " technically this should have a third element in the ok == true case, containing host-syntax", " but the syntax will always be nil, and the errors are annoying", { "tuple-desc-elem-implicit", { { "tuple-desc-elem-explicit", "host-type" }, { "tuple-desc-empty", "host-type" }, { "lambda", { }, "host-bool" } }, { "lambda", { "ok", ":", "host-bool" }, { "host-if", "ok", "ascribed-segment-tuple-desc-reducer-thread-type", "host-lua-error" } } } }, " FIXME: ascribed_segment_tuple_desc can only produce tuple descs in star-0", { "let", "ascribed-segment-tuple-desc-reducer", "=", "intrinsic", { elements = { "return base_env.ascribed_segment_tuple_desc" }, kind = "string" }, ":", { "reducer-type", "ascribed-segment-tuple-desc-reducer-storage-desc", "ascribed-segment-tuple-desc-reducer-result2-desc" } }, { "let", "ascribed-segment-tuple-desc-match-accept-handler", "=", "intrinsic", { elements = { "return metalanguage.accept_handler" }, kind = "string" }, ":", { "reducible-handler-type", "host-unit", "ascribed-segment-tuple-desc-reducer-result2-desc", "ascribed-segment-tuple-desc-match-result-desc" } }, { "let", "ascribed-segment-tuple-desc-match-failure-handler", "=", "intrinsic", { elements = { "return metalanguage.failure_handler" }, kind = "string" }, ":", { "failure-handler-type", "host-unit", "ascribed-segment-tuple-desc-match-result-desc" } }, { "let", "tuple-desc-impl-type", "=", { "operative-handler-type", "host-unit" } }, { "let", "tuple-desc-impl", "=", "lambda", { { "syn", ":", "host-syntax" }, { "env", ":", "host-environment" }, { "ud", ":", "host-unit" }, { "goal", ":", "host-goal" } }, { "let", "s", "=", { { "host-tuple-of", "ascribed-segment-tuple-desc-reducer-storage-desc" }, "env" } }, { "let", "matcher-t", "=", { "host-matcher", "host-unit", "ascribed-segment-tuple-desc-match-result-desc" } }, { "let", "matcher", "=", { "host-matcher-reducible", "ascribed-segment-tuple-desc-reducer-storage-desc", "ascribed-segment-tuple-desc-reducer-result2-desc", "ascribed-segment-tuple-desc-match-result-desc", "ascribed-segment-tuple-desc-reducer", "s", "ascribed-segment-tuple-desc-match-accept-handler" } }, { "let", "matchers", "=", { "host-array-set", { "host-array-new", "matcher-t" }, 1, "matcher" } }, { "let", { "ok", "thread" }, "=", { "match-syntax", "host-unit", "ascribed-segment-tuple-desc-match-result-desc", "matchers", "ascribed-segment-tuple-desc-match-failure-handler", "syn", "host-nil" } }, { "let", "thread", "=", { "error-filter", "ascribed-segment-tuple-desc-reducer-thread-type", "host-lua-error", "ok", "thread" } }, { "let", { "args" }, "=", { "ascribed-segment-tuple-desc-reducer-thread-type-get-args", "thread" } }, { "let", { "env" }, "=", { "ascribed-segment-tuple-desc-reducer-thread-type-get-env", "thread" } }, { "let", { "args" }, "=", { "goalify-inferrable", "goal", "args" } }, { { "tuple-of-explicit", "host-type", { "operative-result-desc", "goal" } }, "args", "env" } }, "let (tuple-desc-op-type, tuple-desc) = new-operative(host-unit, host-nil, tuple-desc-impl)", { "let", "tuple-desc", "=", { "core-operative", "host-nil", "tuple-desc-impl" } }, " tuple-desc for single-element tuples currently require an extra pair of parens, like lambdas used to.", " This should eventually be fixed the same way lambdas were fixed.", { "let", "terms-gen-map", "=", { "new-host-type", { "new-host-unique-id", { elements = { "terms-gen-map" }, kind = "string" } } } }, { "let", "listtail-accepter-result", "=", "lambda", { { "result", ":", { "tuple-desc-type", "host-type" } } }, { "tuple-desc-concat-indep", "result", { "tuple-desc-singleton", "host-type", "host-syntax" } } }, { "let", "listtail-reducer", "=", { "lambda_implicit", { "userdata", ":", "host-type" }, { "lambda_implicit", { "result", ":", { "tuple-desc-type", "host-type" } }, { "lambda", { { "matcher", ":", { "host-matcher", "userdata", "result" } } }, { "intrinsic", { elements = { "return metalanguage.listtail" }, kind = "string" }, ":", { "reducer-type", { "tuple-desc-empty", "host-type" }, "result" } } } } } }, " let enum-desc-impl = lambda (syn : host-syntax, env : host-environment, ud : host-unit, goal : host-goal)", " \tlet matcher-t = host-matcher(host-unit, enum-desc-match-result-desc)", " \tlet matcher =", " \t\thost-matcher-reducible", " \t\t\thost-unit", " \t\t\tenum-desc-reducer-storage-desc", " \t\t\tenum-desc-reducer-result2-desc", " \t\t\tenum-desc-match-result-desc", " \t\t\tenum-desc-reducer", " \t\t\ts", " \t\t\tenum-desc-match-accept-handler", " \tlet matchers =", " \t\thost-array-set", " \t\t\thost-array-new matcher-t", " \t\t\t1", " \t\t\tmatcher", " \tlet (ok, map) =", " \t\tmatch-syntax", " \t\t\thost-unit", " \t\t\tenum-desc-match-result-desc", " \t\t\tmatchers", " \t\t\tenum-desc-match-failure-handler", " \t\t\tsyn", " \t\t\thost-nil", " \tlet map = error-filter(terms-gen-map, host-lua-error, ok, map)", " \taa", " \taa", "     a", { "let", "host-arith-binop", "=", { "host-func-type", { { "a", ":", "host-number" }, { "b", ":", "host-number" } }, "->", { { "c", ":", "host-number" } } } }, { "let", "host-arith-urnop", "=", { "host-func-type", { { "a", ":", "host-number" } }, "->", { { "b", ":", "host-number" } } } }, { "let", "host-mul", "=", { "intrinsic", { elements = { "return function(a, b) return U.notail(a * b) end" }, kind = "string" }, ":", "host-arith-binop" } }, { "let", "host-div", "=", { "intrinsic", { elements = { "return function(a, b) return U.notail(a / b) end" }, kind = "string" }, ":", "host-arith-binop" } }, { "let", "host-mod", "=", { "intrinsic", { elements = { "return function(a, b) return U.notail(a % b) end" }, kind = "string" }, ":", "host-arith-binop" } }, { "let", "host-add", "=", { "intrinsic", { elements = { "return function(a, b) return U.notail(a + b) end" }, kind = "string" }, ":", "host-arith-binop" } }, { "let", "host-sub", "=", { "intrinsic", { elements = { "return function(a, b) return U.notail(a - b) end" }, kind = "string" }, ":", "host-arith-binop" } }, { "let", "host-neg", "=", { "intrinsic", { elements = { "return function(a) return U.notail(-a) end" }, kind = "string" }, ":", "host-arith-urnop" } }, { "let", "mul", "=", "lambda", { { "a", ":", "host-number" }, { "b", ":", "host-number" } }, { "let", { "c" }, "=", { "host-mul", "a", "b" } }, "c" }, { "let", "div", "=", "lambda", { { "a", ":", "host-number" }, { "b", ":", "host-number" } }, { "let", { "c" }, "=", { "host-div", "a", "b" } }, "c" }, { "let", "mod", "=", "lambda", { { "a", ":", "host-number" }, { "b", ":", "host-number" } }, { "let", { "c" }, "=", { "host-mod", "a", "b" } }, "c" }, { "let", "add", "=", "lambda", { { "a", ":", "host-number" }, { "b", ":", "host-number" } }, { "let", { "c" }, "=", { "host-add", "a", "b" } }, "c" }, { "let", "sub", "=", "lambda", { { "a", ":", "host-number" }, { "b", ":", "host-number" } }, { "let", { "c" }, "=", { "host-sub", "a", "b" } }, "c" }, { "let", "neg", "=", "lambda", { "a", ":", "host-number" }, { "let", { "b" }, "=", { "host-neg", "a" } }, "b" }, { "let", "_*_", "=", "mul" }, { "let", "_/_", "=", "div" }, { "let", "_%_", "=", "mod" }, { "let", "_+_", "=", "add" }, { "let", "_-_", "=", "sub" }, " let host-predicate-binop = lambda (T : host-type, U : host-type)\nhost-func-type (a : T, b : U) -> ((c : host-bool))", " let host-lt = (intrinsic \"return function(a, b) return U.notail(a < b) end\" : host-predicate-binop(host-number, host-number))", " let host-eq = (intrinsic \"return function(a, b) return U.notail(a == b) end\" : host-predicate-binop(host-number, host-number))", " let lt = lambda (a : host-number, b : host-number)\nlet (c) = host-lt(a, b)\nc", " let eq = lambda (a : host-number, b : host-number)\nlet (c) = host-eq(a, b)\nc" }
