{ { "let", "wgpu-bool", "=", "host-bool" }, { "let", "wgpu-float", "=", "host-number" }, { "let", "wgpu-vec2", "=", { "new-host-type", { "new-host-unique-id", { elements = { "wgpu-vec2" }, kind = "string" } } } }, { "let", "wgpu-vec3", "=", { "new-host-type", { "new-host-unique-id", { elements = { "wgpu-vec3" }, kind = "string" } } } }, { "let", "wgpu-vec4", "=", { "new-host-type", { "new-host-unique-id", { elements = { "wgpu-vec4" }, kind = "string" } } } }, { "let", "wgpu-mat4", "=", { "new-host-type", { "new-host-unique-id", { elements = { "wgpu-mat4" }, kind = "string" } } } }, { "let", "host-add-float", "=", "intrinsic", { elements = { "local host_add_float = function(l, r) return l + r end\nglsl_registry[host_add_float] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" + \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_add_float" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, "->", { { "sum", ":", "wgpu-float" } } } }, { "let", "_+_", "=", "lambda", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, { "let", { "sum" }, "=", { "host-add-float", "left", "right" } }, "sum" }, { "let", "host-sub-float", "=", "intrinsic", { elements = { "local host_sub_float = function(l, r) return l - r end\nglsl_registry[host_sub_float] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" - \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_sub_float" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, "->", { { "difference", ":", "wgpu-float" } } } }, { "let", "_-_", "=", "lambda", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, { "let", { "difference" }, "=", { "host-sub-float", "left", "right" } }, "difference" }, { "let", "host-mul-float", "=", "intrinsic", { elements = { "local host_mul_float = function(l, r) return l * r end\nglsl_registry[host_mul_float] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" * \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_mul_float" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, "->", { { "product", ":", "wgpu-float" } } } }, { "let", "_*_", "=", "lambda", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, { "let", { "product" }, "=", { "host-mul-float", "left", "right" } }, "product" }, { "let", "host-mul-vec2", "=", "intrinsic", { elements = { "local host_mul_vec2 = function(l, r) return setmetatable({\n\t\tx = l.x * r.x,\n\t\ty = l.y * r.y,\n\t}, glsl_registry[\"vec2f\"]) end\nglsl_registry[host_mul_vec2] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" * \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_mul_vec2" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-vec2" }, { "right", ":", "wgpu-vec2" } }, "->", { { "product", ":", "wgpu-vec2" } } } }, { "let", "_:*:_", "=", "lambda", { { "left", ":", "wgpu-vec2" }, { "right", ":", "wgpu-vec2" } }, { "let", { "product" }, "=", { "host-mul-vec2", "left", "right" } }, "product" }, { "let", "host-mul-vec4", "=", "intrinsic", { elements = { "local host_mul_vec4 = function(l, r) return setmetatable({\n\t\tx = l.x * r.x,\n\t\ty = l.y * r.y,\n\t\tz = l.z * r.z,\n\t\tw = l.w * r.w,\n\t}, glsl_registry[\"vec4f\"]) end\nglsl_registry[host_mul_vec4] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" * \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_mul_vec4" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-vec4" }, { "right", ":", "wgpu-vec4" } }, "->", { { "product", ":", "wgpu-vec4" } } } }, { "let", "_::*::_", "=", "lambda", { { "left", ":", "wgpu-vec4" }, { "right", ":", "wgpu-vec4" } }, { "let", { "product" }, "=", { "host-mul-vec4", "left", "right" } }, "product" }, { "let", "mul-vec4", "=", "lambda", { { "left", ":", "wgpu-vec4" }, { "right", ":", "wgpu-vec4" } }, { "let", { "product" }, "=", { "host-mul-vec4", "left", "right" } }, "product" }, " doesn't work???", { "let", "host-mul-gen", "=", "intrinsic", { elements = { "local host_mul = function(t, u, l, r)\n\tlocal t = {}\n\tif getmetatable(l) and getmetatable(r) then\n\t\tfor k, v in pairs(l) do\n\t\t\tt[k] = v * r[k]\n\t\tend\n\t\treturn setmetatable(t, getmetatable(l))\n\telseif getmetatable(l) then\n\t\tfor k, v in pairs(l) do\n\t\t\tt[k] = v * r\n\t\tend\n\t\treturn setmetatable(t, getmetatable(l))\n\telseif getmetatable(r) then\n\t\tfor k, v in pairs(r) do\n\t\t\tt[k] = v * l\n\t\tend\n\t\treturn setmetatable(t, getmetatable(r))\n\telse\n\t\treturn l * r\n\tend\nend\nglsl_registry[host_mul] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" * \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_mul" }, kind = "string" }, ":", { "host-func-type", { { "T", ":", { "wrapped", "host-type" } }, { "U", ":", { "wrapped", "host-type" } }, { "left", ":", { "unwrap", "T" } }, { "right", ":", { "unwrap", "U" } } }, "->", { { "product", ":", { "unwrap", "T" } } } } }, "let _*_ = lambda (left : wgpu-float, right : wgpu-float)", "\tlet (product) = host-mul-gen(wrap(wgpu-float), wrap(wgpu-float), left, right)", "\tproduct", "let _:*._ = lambda (left : wgpu-vec2, right : wgpu-float)", "\tlet (product) = host-mul-gen(wrap(wgpu-vec2), wrap(wgpu-float), left, right)", "\tproduct", "let _:*:_ = lambda (left : wgpu-vec2, right : wgpu-vec2)", "\tlet (product) = host-mul-gen(wrap(wgpu-vec2), wrap(wgpu-vec2), left, right)", "\tproduct", "let _::*._ = lambda (left : wgpu-vec4, right : wgpu-float)", "\tlet (product) = host-mul-gen(wrap(wgpu-vec4), wrap(wgpu-vec4), left, right)", "\tproduct", "let _::*::_ = lambda (left : wgpu-vec4, right : wgpu-vec4)", "\tlet (product) = host-mul-gen(wrap(wgpu-vec4), wrap(wgpu-vec4), left, right)", "\tproduct", { "let", "host-div-float", "=", "intrinsic", { elements = { "local host_div_float = function(l, r) return l / r end\nglsl_registry[host_div_float] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" / \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_div_float" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, "->", { { "quotient", ":", "wgpu-float" } } } }, { "let", "_/_", "=", "lambda", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, { "let", { "quotient" }, "=", { "host-div-float", "left", "right" } }, "quotient" }, { "let", "host-lt-float", "=", "intrinsic", { elements = { "local host_lt_float = function(l, r) return l < r end\nglsl_registry[host_lt_float] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" < \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_lt_float" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, "->", { { "result", ":", "wgpu-bool" } } } }, { "let", "_<_", "=", "lambda", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, { "let", { "result" }, "=", { "host-lt-float", "left", "right" } }, "result" }, { "let", "host-gt-float", "=", "intrinsic", { elements = { "local host_gt_float = function(l, r) return l > r end\nglsl_registry[host_gt_float] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" > \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_gt_float" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, "->", { { "result", ":", "wgpu-bool" } } } }, { "let", "_>_", "=", "lambda", { { "left", ":", "wgpu-float" }, { "right", ":", "wgpu-float" } }, { "let", { "result" }, "=", { "host-gt-float", "left", "right" } }, "result" }, { "let", "host-clamp", "=", "intrinsic", { elements = { "local host_clamp = function(x, minVal, maxVal)\n\tif x < minVal then\n\t\treturn minVal\n\telseif x > maxVal then\n\t\treturn maxVal\n\telse\n\t\treturn x\n\tend\nend\nglsl_registry[host_clamp] = function(pp, varnames, x, minVal, maxVal)\n\tpp:unit(\"clamp(\")\n\tpp:any(x, varnames)\n\tpp:unit(\", \")\n\tpp:any(minVal, varnames)\n\tpp:unit(\", \")\n\tpp:any(maxVal, varnames)\n\tpp:unit(\")\")\nend\nreturn host_clamp" }, kind = "string" }, ":", { "host-func-type", { { "x", ":", "wgpu-float" }, { "minVal", ":", "wgpu-float" }, { "maxVal", ":", "wgpu-float" } }, "->", { { "clamped", ":", "wgpu-float" } } } }, { "let", "clamp", "=", "lambda", { { "x", ":", "wgpu-float" }, { "minVal", ":", "wgpu-float" }, { "maxVal", ":", "wgpu-float" } }, { "let", { "clamped" }, "=", { "host-clamp", "x", "minVal", "maxVal" } }, "clamped" }, { "let", "host-max", "=", "intrinsic", { elements = { "local host_max = function(x, minVal)\n\tif x < minVal then\n\t\treturn minVal\n\telse\n\t\treturn x\n\tend\nend\nglsl_registry[host_max] = function(pp, varnames, x, minVal)\n\tpp:unit(\"max(\")\n\tpp:any(x, varnames)\n\tpp:unit(\", \")\n\tpp:any(minVal, varnames)\n\tpp:unit(\")\")\nend\nreturn host_max" }, kind = "string" }, ":", { "host-func-type", { { "x", ":", "wgpu-float" }, { "maxVal", ":", "wgpu-float" } }, "->", { { "maxed", ":", "wgpu-float" } } } }, { "let", "max", "=", "lambda", { { "x", ":", "wgpu-float" }, { "maxVal", ":", "wgpu-float" } }, { "let", { "maxed" }, "=", { "host-max", "x", "maxVal" } }, "maxed" }, { "let", "host-min", "=", "intrinsic", { elements = { "local host_min = function(x, minVal)\n\tif x > minVal then\n\t\treturn minVal\n\telse\n\t\treturn x\n\tend\nend\nglsl_registry[host_min] = function(pp, varnames, x, minVal)\n\tpp:unit(\"min(\")\n\tpp:any(x, varnames)\n\tpp:unit(\", \")\n\tpp:any(minVal, varnames)\n\tpp:unit(\")\")\nend\nreturn host_min" }, kind = "string" }, ":", { "host-func-type", { { "x", ":", "wgpu-float" }, { "minVal", ":", "wgpu-float" } }, "->", { { "mined", ":", "wgpu-float" } } } }, { "let", "min", "=", "lambda", { { "x", ":", "wgpu-float" }, { "minVal", ":", "wgpu-float" } }, { "let", { "mined" }, "=", { "host-min", "x", "minVal" } }, "mined" }, { "let", "host-ternary", "=", "intrinsic", { elements = { "local host_ternary = function(condition, consequent, alternate)\n\tif condition then\n\t\treturn consequent\n\telse\n\t\treturn alternate\n\tend\nend\nglsl_registry[host_ternary] = function(pp, varnames, condition, consequent, alternate)\n\tpp:unit(\"select(\")\n\tpp:any(alternate, varnames)\n\tpp:unit(\", \")\n\tpp:any(consequent, varnames)\n\tpp:unit(\", \")\n\tpp:any(condition, varnames)\n\tpp:unit(\")\")\nend\nreturn host_ternary" }, kind = "string" }, ":", { "host-func-type", { { "condition", ":", "wgpu-bool" }, { "consequent", ":", "wgpu-float" }, { "alternate", ":", "wgpu-float" } }, "->", { { "result", ":", "wgpu-float" } } } }, { "let", "ternary", "=", "lambda", { { "condition", ":", "wgpu-bool" }, { "consequent", ":", "wgpu-float" }, { "alternate", ":", "wgpu-float" } }, { "let", { "result" }, "=", { "host-ternary", "condition", "consequent", "alternate" } }, "result" }, { "let", "host-fwidth", "=", "intrinsic", { elements = { "-- This returns the derivative of the values relative to the current surface dimensions, which is not possible to do here\nlocal host_fwidth = function(v) return 1.0\tend\nglsl_registry[host_fwidth] = function(pp, varnames, v)\n\tpp:unit(\"fwidth(\")\n\tpp:any(v, varnames)\n\tpp:unit(\")\")\nend\nreturn host_fwidth" }, kind = "string" }, ":", { "host-func-type", { { "v", ":", "wgpu-float" } }, "->", { { "result", ":", "wgpu-float" } } } }, { "let", "fwidth", "=", "lambda", { "v", ":", "wgpu-float" }, { "let", { "result" }, "=", { "host-fwidth", "v" } }, "result" }, { "let", "host-dot", "=", "intrinsic", { elements = { "local host_dot = function(l, r) return l.x * r.x + l.y * r.y\tend\nglsl_registry[host_dot] = function(pp, varnames, l, r)\n\tpp:unit(\"dot(\")\n\tpp:any(l, varnames)\n\tpp:unit(\", \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_dot" }, kind = "string" }, ":", { "host-func-type", { { "l", ":", "wgpu-vec2" }, { "r", ":", "wgpu-vec2" } }, "->", { { "result", ":", "wgpu-float" } } } }, { "let", "dot", "=", "lambda", { { "l", ":", "wgpu-vec2" }, { "r", ":", "wgpu-vec2" } }, { "let", { "result" }, "=", { "host-dot", "l", "r" } }, "result" }, { "let", "host-normalize", "=", "intrinsic", { elements = { "local host_normalize = function(v)\n\tlocal l = math.sqrt(v.x * v.x + v.y * v.y)\n\treturn setmetatable({x = v.x / l, y = v.y / l}, glsl_registry[\"vec2f\"])\nend\nglsl_registry[host_normalize] = function(pp, varnames, v)\n\tpp:unit(\"normalize(\")\n\tpp:any(v, varnames)\n\tpp:unit(\")\")\nend\nreturn host_normalize" }, kind = "string" }, ":", { "host-func-type", { { "v", ":", "wgpu-vec2" } }, "->", { { "result", ":", "wgpu-vec2" } } } }, { "let", "normalize", "=", "lambda", { "v", ":", "wgpu-vec2" }, { "let", { "result" }, "=", { "host-normalize", "v" } }, "result" }, { "let", "host-length", "=", "intrinsic", { elements = { "local host_length = function(v) return math.sqrt(v.x * v.x + v.y * v.y) end\nglsl_registry[host_length] = function(pp, varnames, v)\n\tpp:unit(\"length(\")\n\tpp:any(v, varnames)\n\tpp:unit(\")\")\nend\nreturn host_length" }, kind = "string" }, ":", { "host-func-type", { { "v", ":", "wgpu-vec2" } }, "->", { { "result", ":", "wgpu-float" } } } }, { "let", "length", "=", "lambda", { "v", ":", "wgpu-vec2" }, { "let", { "result" }, "=", { "host-length", "v" } }, "result" }, { "let", "host-mk-vec2", "=", "intrinsic", { elements = { "local vec2_mt = {}\nlocal host_mk_vec2 = function(x, y) return setmetatable({ x = x, y = y }, vec2_mt) end\nglsl_registry[host_mk_vec2] = function(pp, varnames, x, y)\n\tpp:unit(\"vec2f(\")\n\tpp:any(x, varnames)\n\tpp:unit(\", \")\n\tpp:any(y, varnames)\n\tpp:unit(\")\")\nend\nglsl_registry[vec2_mt] = function(pp, vec, varnames)\n\treturn glsl_registry[host_mk_vec2](pp, varnames, vec.x, vec.y)\nend\nglsl_registry[\"vec2f\"] = vec2_mt\nreturn host_mk_vec2" }, kind = "string" }, ":", { "host-func-type", { { "x", ":", "wgpu-float" }, { "y", ":", "wgpu-float" } }, "->", { { "vec", ":", "wgpu-vec2" } } } }, { "let", "mk-vec2", "=", "lambda", { { "x", ":", "wgpu-float" }, { "y", ":", "wgpu-float" } }, { "let", { "vec" }, "=", { "host-mk-vec2", "x", "y" } }, "vec" }, { "let", "mk-vec2-float", "=", "lambda", { "x", ":", "wgpu-float" }, { "let", { "vec" }, "=", { "host-mk-vec2", "x", "x" } }, "vec" }, { "let", "host-get-vec2-x", "=", "intrinsic", { elements = { "local host_get_vec2_x = function(vec) return vec.x end\nglsl_registry[host_get_vec2_x] = function(pp, varnames, vec)\n\tpp:any(vec, varnames)\n\tpp:unit(\".x\")\nend\nreturn host_get_vec2_x" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec2" } }, "->", { { "x", ":", "wgpu-float" } } } }, { "let", "host-get-vec2-y", "=", "intrinsic", { elements = { "local host_get_vec2_y = function(vec) return vec.y end\nglsl_registry[host_get_vec2_y] = function(pp, varnames, vec)\n\tpp:any(vec, varnames)\n\tpp:unit(\".y\")\nend\nreturn host_get_vec2_y" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec2" } }, "->", { { "y", ":", "wgpu-float" } } } }, { "let", "split-vec2", "=", "lambda", { "vec", ":", "wgpu-vec2" }, { "let", { "x" }, "=", { "host-get-vec2-x", "vec" } }, { "let", { "y" }, "=", { "host-get-vec2-y", "vec" } }, { "tuple-of", "x", "y" } }, { "let", "host-add-vec2", "=", "intrinsic", { elements = { "local host_add_vec2 = function(l, r)\n\treturn setmetatable({\n\t\tx = l.x + r.x,\n\t\ty = l.y + r.y,\n\t}, glsl_registry[\"vec2f\"])\nend\nglsl_registry[host_add_vec2] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" + \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_add_vec2" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-vec2" }, { "right", ":", "wgpu-vec2" } }, "->", { { "sum", ":", "wgpu-vec2" } } } }, { "let", "add-vec2", "=", "lambda", { { "left", ":", "wgpu-vec2" }, { "right", ":", "wgpu-vec2" } }, { "let", { "sum" }, "=", { "host-add-vec2", "left", "right" } }, "sum" }, { "let", "host-add-vec4", "=", "intrinsic", { elements = { "local host_add_vec4 = function(l, r)\n\treturn setmetatable({\n\t\tx = l.x + r.x,\n\t\ty = l.y + r.y,\n\t\tz = l.z + r.z,\n\t\tw = l.w + r.w,\n\t}, glsl_registry[\"vec4f\"])\nend\nglsl_registry[host_add_vec4] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" + \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_add_vec4" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-vec4" }, { "right", ":", "wgpu-vec4" } }, "->", { { "sum", ":", "wgpu-vec4" } } } }, { "let", "add-vec4", "=", "lambda", { { "left", ":", "wgpu-vec4" }, { "right", ":", "wgpu-vec4" } }, { "let", { "sum" }, "=", { "host-add-vec4", "left", "right" } }, "sum" }, { "let", "host-sub-vec2", "=", "intrinsic", { elements = { "local host_sub_vec2 = function(l, r)\n\treturn setmetatable({\n\t\tx = l.x - r.x,\n\t\ty = l.y - r.y,\n\t}, glsl_registry[\"vec2f\"])\nend\nglsl_registry[host_sub_vec2] = function(pp, varnames, l, r)\n\tpp:unit(\"(\")\n\tpp:any(l, varnames)\n\tpp:unit(\" - \")\n\tpp:any(r, varnames)\n\tpp:unit(\")\")\nend\nreturn host_sub_vec2" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-vec2" }, { "right", ":", "wgpu-vec2" } }, "->", { { "difference", ":", "wgpu-vec2" } } } }, { "let", "sub-vec2", "=", "lambda", { { "left", ":", "wgpu-vec2" }, { "right", ":", "wgpu-vec2" } }, { "let", { "difference" }, "=", { "host-sub-vec2", "left", "right" } }, "difference" }, { "let", "host-abs-vec2", "=", "intrinsic", { elements = { "local host_abs_vec2 = function(vec)\n\treturn setmetatable({\n\t\tx = math.abs(vec.x),\n\t\ty = math.abs(vec.y),\n\t}, glsl_registry[\"vec2f\"])\nend\nglsl_registry[host_abs_vec2] = function(pp, varnames, vec)\n\tpp:unit(\"abs(\")\n\tpp:any(vec, varnames)\n\tpp:unit(\")\")\nend\nreturn host_abs_vec2" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec2" } }, "->", { { "result", ":", "wgpu-vec2" } } } }, { "let", "abs-vec2", "=", "lambda", { "vec", ":", "wgpu-vec2" }, { "let", { "result" }, "=", { "host-abs-vec2", "vec" } }, "result" }, { "let", "host-abs-float", "=", "intrinsic", { elements = { "local host_abs_float = function(v)\n\treturn math.abs(v)\nend\nglsl_registry[host_abs_float] = function(pp, varnames, v)\n\tpp:unit(\"abs(\")\n\tpp:any(v, varnames)\n\tpp:unit(\")\")\nend\nreturn host_abs_float" }, kind = "string" }, ":", { "host-func-type", { { "v", ":", "wgpu-float" } }, "->", { { "result", ":", "wgpu-float" } } } }, { "let", "abs", "=", "lambda", { "v", ":", "wgpu-float" }, { "let", { "result" }, "=", { "host-abs-float", "v" } }, "result" }, { "let", "host-pow-float", "=", "intrinsic", { elements = { "local host_pow_float = function(v, p)\n\treturn math.pow(v, p)\nend\nglsl_registry[host_pow_float] = function(pp, varnames, v, p)\n\tpp:unit(\"pow(\")\n\tpp:any(v, varnames)\n\tpp:unit(\", \")\n\tpp:any(p, varnames)\n\tpp:unit(\")\")\nend\nreturn host_pow_float" }, kind = "string" }, ":", { "host-func-type", { { "v", ":", "wgpu-float" }, { "p", ":", "wgpu-float" } }, "->", { { "result", ":", "wgpu-float" } } } }, { "let", "pow", "=", "lambda", { { "v", ":", "wgpu-float" }, { "p", ":", "wgpu-float" } }, { "let", { "result" }, "=", { "host-pow-float", "v", "p" } }, "result" }, { "let", "host-mk-vec4", "=", "intrinsic", { elements = { "local vec4_mt = {}\nlocal host_mk_vec4 = function(x, y, z, w) return setmetatable({ x = x, y = y, z = z, w = w }, vec4_mt) end\nglsl_registry[host_mk_vec4] = function(pp, varnames, x, y, z, w)\n\tpp:unit(\"vec4f(\")\n\tpp:any(x, varnames)\n\tpp:unit(\", \")\n\tpp:any(y, varnames)\n\tpp:unit(\", \")\n\tpp:any(z, varnames)\n\tpp:unit(\", \")\n\tpp:any(w, varnames)\n\tpp:unit(\")\")\nend\nglsl_registry[vec4_mt] = function(pp, vec, varnames)\n\treturn glsl_registry[host_mk_vec4](pp, varnames, vec.x, vec.y, vec.z, vec.w)\nend\nglsl_registry[\"vec4f\"] = vec4_mt\nreturn host_mk_vec4" }, kind = "string" }, ":", { "host-func-type", { { "x", ":", "wgpu-float" }, { "y", ":", "wgpu-float" }, { "z", ":", "wgpu-float" }, { "w", ":", "wgpu-float" } }, "->", { { "vec", ":", "wgpu-vec4" } } } }, { "let", "mk-vec4", "=", "lambda", { { "x", ":", "wgpu-float" }, { "y", ":", "wgpu-float" }, { "z", ":", "wgpu-float" }, { "w", ":", "wgpu-float" } }, { "let", { "vec" }, "=", { "host-mk-vec4", "x", "y", "z", "w" } }, "vec" }, { "let", "mk-vec4-float", "=", "lambda", { "x", ":", "wgpu-float" }, { "let", { "vec" }, "=", { "host-mk-vec4", "x", "x", "x", "x" } }, "vec" }, { "let", "host-get-vec4-x", "=", "intrinsic", { elements = { "local host_get_vec4_x = function(vec) return vec.x end\nglsl_registry[host_get_vec4_x] = function(pp, varnames, vec)\n\tpp:any(vec, varnames)\n\tpp:unit(\".x\")\nend\nreturn host_get_vec4_x" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec4" } }, "->", { { "x", ":", "wgpu-float" } } } }, { "let", "host-get-vec4-y", "=", "intrinsic", { elements = { "local host_get_vec4_y = function(vec) return vec.y end\nglsl_registry[host_get_vec4_y] = function(pp, varnames, vec)\n\tpp:any(vec, varnames)\n\tpp:unit(\".y\")\nend\nreturn host_get_vec4_y" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec4" } }, "->", { { "y", ":", "wgpu-float" } } } }, { "let", "host-get-vec4-z", "=", "intrinsic", { elements = { "local host_get_vec4_z = function(vec) return vec.z end\nglsl_registry[host_get_vec4_z] = function(pp, varnames, vec)\n\tpp:any(vec, varnames)\n\tpp:unit(\".z\")\nend\nreturn host_get_vec4_z" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec4" } }, "->", { { "z", ":", "wgpu-float" } } } }, { "let", "host-get-vec4-w", "=", "intrinsic", { elements = { "local host_get_vec4_w = function(vec) return vec.w end\nglsl_registry[host_get_vec4_w] = function(pp, varnames, vec)\n\tpp:any(vec, varnames)\n\tpp:unit(\".w\")\nend\nreturn host_get_vec4_w" }, kind = "string" }, ":", { "host-func-type", { { "vec", ":", "wgpu-vec4" } }, "->", { { "w", ":", "wgpu-float" } } } }, { "let", "split-vec4", "=", "lambda", { "vec", ":", "wgpu-vec4" }, { "let", { "x" }, "=", { "host-get-vec4-x", "vec" } }, { "let", { "y" }, "=", { "host-get-vec4-y", "vec" } }, { "let", { "z" }, "=", { "host-get-vec4-z", "vec" } }, { "let", { "w" }, "=", { "host-get-vec4-w", "vec" } }, { "tuple-of", "x", "y", "z", "w" } }, { "let", "host-mk-mat4", "=", "intrinsic", { elements = { "local mat4_mt = {}\nlocal host_mk_mat4 = function(a, b, c, d)\n\treturn setmetatable({\n\t\tax = a.x, bx = b.x, cx = c.x, dx = d.x,\n\t\tay = a.y, by = b.y, cy = c.y, dy = d.y,\n\t\taz = a.z, bz = b.z, cz = c.z, dz = d.z,\n\t\taw = a.w, bw = b.w, cw = c.w, dw = d.w,\n\t}, mat4_mt)\nend\nglsl_registry[host_mk_mat4] = function(pp, varnames, a, b, c, d)\n\tpp:unit(\"mat4x4f(\")\n\tpp:any(a, varnames)\n\tpp:unit(\", \")\n\tpp:any(b, varnames)\n\tpp:unit(\", \")\n\tpp:any(c, varnames)\n\tpp:unit(\", \")\n\tpp:any(d, varnames)\n\tpp:unit(\")\")\nend\nglsl_registry[mat4_mt] = function(pp, mat, varnames)\n\tpp:unit(\"/* NYI: repr a mat4! */\")\nend\nglsl_registry[\"mat4x4f\"] = mat4_mt\nreturn host_mk_mat4" }, kind = "string" }, ":", { "host-func-type", { { "a", ":", "wgpu-vec4" }, { "b", ":", "wgpu-vec4" }, { "c", ":", "wgpu-vec4" }, { "d", ":", "wgpu-vec4" } }, "->", { { "mat", ":", "wgpu-mat4" } } } }, { "let", "mk-mat4", "=", "lambda", { { "a", ":", "wgpu-vec4" }, { "b", ":", "wgpu-vec4" }, { "c", ":", "wgpu-vec4" }, { "d", ":", "wgpu-vec4" } }, { "let", { "mat" }, "=", { "host-mk-mat4", "a", "b", "c", "d" } }, "mat" }, { "let", "host-mul-mat4-vec4", "=", "intrinsic", { elements = { "local host_mul_mat4_vec4 = function(left, right)\n\treturn setmetatable({\n\t\tx = left.ax * right.x + left.bx * right.y + left.cx * right.z + left.dx * right.w,\n\t\ty = left.ay * right.x + left.by * right.y + left.cy * right.z + left.dy * right.w,\n\t\tz = left.az * right.x + left.bz * right.y + left.cz * right.z + left.dz * right.w,\n\t\tw = left.aw * right.x + left.bw * right.y + left.cw * right.z + left.dw * right.w,\n\t}, glsl_registry[\"vec4f\"])\nend\nglsl_registry[host_mul_mat4_vec4] = function(pp, varnames, left, right)\n\tpp:unit(\"(\")\n\tpp:any(left, varnames)\n\tpp:unit(\" * \")\n\tpp:any(right, varnames)\n\tpp:unit(\")\")\nend\nreturn host_mul_mat4_vec4" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-mat4" }, { "right", ":", "wgpu-vec4" } }, "->", { { "product", ":", "wgpu-vec4" } } } }, { "let", "mul-mat4-vec4", "=", "lambda", { { "left", ":", "wgpu-mat4" }, { "right", ":", "wgpu-vec4" } }, { "let", { "product" }, "=", { "host-mul-mat4-vec4", "left", "right" } }, "product" }, { "let", "host-mul-mat4-mat4", "=", "intrinsic", { elements = { "local host_mul_mat4_mat4 = function(left, right)\n\treturn setmetatable({\n\t\tax = left.ax * right.ax + left.bx * right.ay + left.cx * right.az + left.dx * right.aw,\n\t\tay = left.ay * right.ax + left.by * right.ay + left.cy * right.az + left.dy * right.aw,\n\t\taz = left.az * right.ax + left.bz * right.ay + left.cz * right.az + left.dz * right.aw,\n\t\taw = left.aw * right.ax + left.bw * right.ay + left.cw * right.az + left.dw * right.aw,\n\n\t\tbx = left.ax * right.bx + left.bx * right.by + left.cx * right.bz + left.dx * right.bw,\n\t\tby = left.ay * right.bx + left.by * right.by + left.cy * right.bz + left.dy * right.bw,\n\t\tbz = left.az * right.bx + left.bz * right.by + left.cz * right.bz + left.dz * right.bw,\n\t\tbw = left.aw * right.bx + left.bw * right.by + left.cw * right.bz + left.dw * right.bw,\n\n\t\tcx = left.ax * right.cx + left.bx * right.cy + left.cx * right.cz + left.dx * right.cw,\n\t\tcy = left.ay * right.cx + left.by * right.cy + left.cy * right.cz + left.dy * right.cw,\n\t\tcz = left.az * right.cx + left.bz * right.cy + left.cz * right.cz + left.dz * right.cw,\n\t\tcw = left.aw * right.cx + left.bw * right.cy + left.cw * right.cz + left.dw * right.cw,\n\n\t\tdx = left.ax * right.dx + left.bx * right.dy + left.cx * right.dz + left.dx * right.dw,\n\t\tdy = left.ay * right.dx + left.by * right.dy + left.cy * right.dz + left.dy * right.dw,\n\t\tdz = left.az * right.dx + left.bz * right.dy + left.cz * right.dz + left.dz * right.dw,\n\t\tdw = left.aw * right.dx + left.bw * right.dy + left.cw * right.dz + left.dw * right.dw,\n\t}, glsl_registry[\"mat4x4\"])\nend\nglsl_registry[host_mul_mat4_mat4] = function(pp, varnames, left, right)\n\tpp:unit(\"(\")\n\tpp:any(left, varnames)\n\tpp:unit(\" * \")\n\tpp:any(right, varnames)\n\tpp:unit(\")\")\nend\nreturn host_mul_mat4_mat4" }, kind = "string" }, ":", { "host-func-type", { { "left", ":", "wgpu-mat4" }, { "right", ":", "wgpu-mat4" } }, "->", { { "product", ":", "wgpu-mat4" } } } }, { "let", "mul-mat4-mat4", "=", "lambda", { { "left", ":", "wgpu-mat4" }, { "right", ":", "wgpu-mat4" } }, { "let", { "product" }, "=", { "host-mul-mat4-mat4", "left", "right" } }, "product" } }
